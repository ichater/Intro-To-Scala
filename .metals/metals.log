2020.12.04 12:50:24 INFO  Started: Metals version 0.9.7 in workspace 'C:\Users\User\Documents\projects\intro-to-scala' for client vscode.
2020.12.04 12:50:28 INFO  time: initialize in 4.23s
2020.12.04 12:50:30 WARN  Build server is not auto-connectable.
2020.12.04 12:50:30 WARN  no build target for: C:\Users\User\Documents\projects\intro-to-scala\src\main\scala\introcourse\level01\IntroExercises.scala
2020.12.04 12:50:39 INFO  no build target: using presentation compiler with only scala-library
Dec. 04, 2020 12:50:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2
2020.12.04 12:50:43 INFO  running 'C:\Program Files\Java\jdk-11.0.9\bin\java -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\User\AppData\Local\Temp\metals16911227320914797402\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2020.12.04 12:50:44 ERROR [info] [launcher] getting org.fusesource.jansi jansi 1.11  (this may take some time)...
2020.12.04 12:50:59 ERROR downloading https://repo1.maven.org/maven2/org/fusesource/jansi/jansi/1.11/jansi-1.11.jar ...
2020.12.04 12:50:59 ERROR :: loading settings :: url = jar:file:/C:/Users/User/AppData/Local/Temp/metals16911227320914797402/sbt-launch.jar!/org/apache/ivy/core/settings/ivysettings.xml
2020.12.04 12:51:00 ERROR 	[SUCCESSFUL ] org.fusesource.jansi#jansi;1.11!jansi.jar (1062ms)
2020.12.04 12:51:00 ERROR :: retrieving :: org.scala-sbt#boot-jansi
2020.12.04 12:51:00 ERROR 	confs: [default]
2020.12.04 12:51:00 ERROR :: loading settings :: url = jar:file:/C:/Users/User/AppData/Local/Temp/metals16911227320914797402/sbt-launch.jar!/org/apache/ivy/core/settings/ivysettings.xml
2020.12.04 12:51:00 ERROR 	1 artifacts copied, 0 already retrieved
2020.12.04 12:51:05 INFO  [info] welcome to sbt 1.3.13 (Oracle Corporation Java 11.0.9)
2020.12.04 12:51:10 INFO  [info] loading settings for project intro-to-scala-build-build-build from metals.sbt ...
2020.12.04 12:51:10 INFO  [info] loading project definition from C:\Users\User\Documents\projects\intro-to-scala\project\project\project
2020.12.04 12:51:20 INFO  [warn] There may be incompatibilities among your library dependencies; run 'evicted' to see detailed eviction warnings.
2020.12.04 12:51:22 INFO  [info] loading settings for project intro-to-scala-build-build from metals.sbt ...
2020.12.04 12:51:22 INFO  [info] loading project definition from C:\Users\User\Documents\projects\intro-to-scala\project\project
2020.12.04 12:51:25 INFO  [warn] There may be incompatibilities among your library dependencies; run 'evicted' to see detailed eviction warnings.
2020.12.04 12:51:31 INFO  [success] Generated .bloop\intro-to-scala-build-build.json
2020.12.04 12:51:31 INFO  [success] Total time: 8 s, completed 4 Dec. 2020, 12:51:31 pm
2020.12.04 12:51:33 INFO  [info] loading settings for project intro-to-scala-build from metals.sbt,plugins.sbt ...
2020.12.04 12:51:33 INFO  [info] loading project definition from C:\Users\User\Documents\projects\intro-to-scala\project
2020.12.04 12:51:34 INFO  [warn] There may be incompatibilities among your library dependencies; run 'evicted' to see detailed eviction warnings.
2020.12.04 12:51:34 INFO  [success] Generated .bloop\intro-to-scala-build.json
2020.12.04 12:51:34 INFO  [success] Total time: 2 s, completed 4 Dec. 2020, 12:51:35 pm
2020.12.04 12:51:39 INFO  [info] loading settings for project intro-to-scala from build.sbt,delight.sbt,wartremover.sbt ...
2020.12.04 12:51:39 INFO  [info] set current project to intro-to-scala (in build file:/C:/Users/User/Documents/projects/intro-to-scala/)
2020.12.04 12:51:43 INFO  [success] Generated .bloop\intro-to-scala-test.json
2020.12.04 12:51:43 INFO  [success] Generated .bloop\intro-to-scala.json
2020.12.04 12:51:43 INFO  [success] Total time: 4 s, completed 4 Dec. 2020, 12:51:43 pm
2020.12.04 12:51:43 INFO  sbt bloopInstall exit: 0
2020.12.04 12:51:43 INFO  time: ran 'sbt bloopInstall' in 1m
2020.12.04 12:51:43 INFO  Attempting to connect to the build server...
Starting the bsp launcher for bloop...
Opening a bsp server connection with 'bsp --protocol tcp --port 31491'...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
2020.12.04 12:51:52 WARN  code navigation does not work for the file 'C:\Users\User\Documents\projects\intro-to-scala\src\main\scala\introcourse\level01\IntroExercises.scala' because it doesn't belong to a build target.
2020.12.04 12:51:52 WARN  code navigation does not work for the file 'C:\Users\User\Documents\projects\intro-to-scala\src\main\scala\introcourse\level01\IntroExercises.scala' because it doesn't belong to a build target.
2020.12.04 12:51:52 WARN  code navigation does not work for the file 'C:\Users\User\Documents\projects\intro-to-scala\src\main\scala\introcourse\level01\IntroExercises.scala' because it doesn't belong to a build target.
Waiting for the bsp connection to come up...
2020.12.04 12:51:54 WARN  no build target for: C:\Users\User\Documents\projects\intro-to-scala\src\main\scala\introcourse\level01\IntroExercises.scala
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
No server running at 127.0.0.1:8212, let's fire one...
Resolving ch.epfl.scala:bloop-frontend_2.12:1.4.5-6-4768184c...
Starting bloop server at 127.0.0.1:8212...
Attempting a connection to the server...
[0m[32m[D][0m Loading 2 projects from 'c:\Users\User\Documents\projects\intro-to-scala\.bloop'...
[0m[32m[D][0m Loading project from 'c:\Users\User\Documents\projects\intro-to-scala\.bloop\intro-to-scala.json'
[0m[32m[D][0m Loading project from 'c:\Users\User\Documents\projects\intro-to-scala\.bloop\intro-to-scala-test.json'
[0m[32m[D][0m Cache miss for scala instance org.scala-lang:scala-compiler:2.13.3.
[0m[32m[D][0m   => C:\Users\User\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\net\java\dev\jna\jna\5.3.1\jna-5.3.1.jar
[0m[32m[D][0m   => C:\Users\User\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\jline\jline\3.15.0\jline-3.15.0.jar
[0m[32m[D][0m   => C:\Users\User\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-compiler\2.13.3\scala-compiler-2.13.3.jar
[0m[32m[D][0m   => C:\Users\User\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-library\2.13.3\scala-library-2.13.3.jar
[0m[32m[D][0m   => C:\Users\User\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-reflect\2.13.3\scala-reflect-2.13.3.jar
[0m[32m[D][0m Missing analysis file for project 'intro-to-scala'
[0m[32m[D][0m Missing analysis file for project 'intro-to-scala-test'
[0m[32m[D][0m Waiting for a connection at 127.0.0.1:31491...
The server is listening for incoming connections at tcp://127.0.0.1:31491...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
2020.12.04 12:52:21 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2020.12.04 12:52:29 INFO  Attempting to connect to the build server...
Starting the bsp launcher for bloop...
2020.12.04 12:52:29 INFO  Attempting to connect to the build server...
Opening a bsp server connection with 'bsp --protocol tcp --port 42745'...
Waiting for the bsp connection to come up...
Starting the bsp launcher for bloop...
Opening a bsp server connection with 'bsp --protocol tcp --port 43855'...
Waiting for the bsp connection to come up...
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Waiting for a connection at 127.0.0.1:42745...
The server is listening for incoming connections at tcp://127.0.0.1:42745...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Waiting for a connection at 127.0.0.1:43855...
The server is listening for incoming connections at tcp://127.0.0.1:43855...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
2020.12.04 12:52:30 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2020.12.04 12:52:30 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2020.12.04 12:52:36 INFO  time: connected to build server in 52s
2020.12.04 12:52:36 INFO  Connected to Build server v1.4.5-6-4768184c
2020.12.04 12:52:36 INFO  time: imported build in 0.22s
2020.12.04 12:52:45 INFO  time: indexed workspace in 8.91s
2020.12.04 12:52:47 INFO  compiling intro-to-scala (15 scala sources)
2020.12.04 12:53:15 INFO  time: compiled intro-to-scala in 28s
2020.12.04 12:55:12 INFO  compiling intro-to-scala (15 scala sources)
2020.12.04 12:55:15 INFO  time: compiled intro-to-scala in 2.77s
2020.12.04 12:55:29 ERROR code navigation does not work for the file 'C:\Users\User\Documents\projects\intro-to-scala\src\main\scala\introcourse\level01\IntroExercises.scala' because the SemanticDB file 'C:\Users\User\Documents\projects\intro-to-scala\.bloop\intro-to-scala\bloop-bsp-clients-classes\classes-Metals-XL8qEN_nTMOEdX3R1do9Xg==\META-INF\semanticdb\src\main\scala\introcourse\level01\IntroExercises.scala.semanticdb' doesn't exist. There can be many reasons for this error. 
2020.12.04 12:56:28 ERROR code navigation does not work for the file 'C:\Users\User\Documents\projects\intro-to-scala\src\main\scala\introcourse\level01\IntroExercises.scala' because the SemanticDB file 'C:\Users\User\Documents\projects\intro-to-scala\.bloop\intro-to-scala\bloop-bsp-clients-classes\classes-Metals-XL8qEN_nTMOEdX3R1do9Xg==\META-INF\semanticdb\src\main\scala\introcourse\level01\IntroExercises.scala.semanticdb' doesn't exist. There can be many reasons for this error. 
2020.12.04 12:56:29 INFO  compiling intro-to-scala (15 scala sources)
2020.12.04 12:56:30 INFO  time: compiled intro-to-scala in 1.7s
2020.12.04 12:56:32 INFO  compiling intro-to-scala (15 scala sources)
2020.12.04 12:56:34 INFO  time: compiled intro-to-scala in 1.32s
2020.12.04 12:56:39 INFO  compiling intro-to-scala (15 scala sources)
2020.12.04 12:56:40 INFO  time: compiled intro-to-scala in 1.18s
2020.12.04 12:57:59 ERROR code navigation does not work for the file 'C:\Users\User\Documents\projects\intro-to-scala\src\main\scala\introcourse\level01\IntroExercises.scala' because the SemanticDB file 'C:\Users\User\Documents\projects\intro-to-scala\.bloop\intro-to-scala\bloop-bsp-clients-classes\classes-Metals-XL8qEN_nTMOEdX3R1do9Xg==\META-INF\semanticdb\src\main\scala\introcourse\level01\IntroExercises.scala.semanticdb' doesn't exist. There can be many reasons for this error. 
2020.12.04 12:58:11 ERROR code navigation does not work for the file 'C:\Users\User\Documents\projects\intro-to-scala\src\main\scala\introcourse\level01\IntroExercises.scala' because the SemanticDB file 'C:\Users\User\Documents\projects\intro-to-scala\.bloop\intro-to-scala\bloop-bsp-clients-classes\classes-Metals-XL8qEN_nTMOEdX3R1do9Xg==\META-INF\semanticdb\src\main\scala\introcourse\level01\IntroExercises.scala.semanticdb' doesn't exist. There can be many reasons for this error. 
2020.12.04 12:58:14 ERROR code navigation does not work for the file 'C:\Users\User\Documents\projects\intro-to-scala\src\main\scala\introcourse\level01\IntroExercises.scala' because the SemanticDB file 'C:\Users\User\Documents\projects\intro-to-scala\.bloop\intro-to-scala\bloop-bsp-clients-classes\classes-Metals-XL8qEN_nTMOEdX3R1do9Xg==\META-INF\semanticdb\src\main\scala\introcourse\level01\IntroExercises.scala.semanticdb' doesn't exist. There can be many reasons for this error. 
2020.12.04 12:58:21 ERROR code navigation does not work for the file 'C:\Users\User\Documents\projects\intro-to-scala\src\main\scala\introcourse\level01\IntroExercises.scala' because the SemanticDB file 'C:\Users\User\Documents\projects\intro-to-scala\.bloop\intro-to-scala\bloop-bsp-clients-classes\classes-Metals-XL8qEN_nTMOEdX3R1do9Xg==\META-INF\semanticdb\src\main\scala\introcourse\level01\IntroExercises.scala.semanticdb' doesn't exist. There can be many reasons for this error. 
2020.12.04 12:58:22 ERROR code navigation does not work for the file 'C:\Users\User\Documents\projects\intro-to-scala\src\main\scala\introcourse\level01\IntroExercises.scala' because the SemanticDB file 'C:\Users\User\Documents\projects\intro-to-scala\.bloop\intro-to-scala\bloop-bsp-clients-classes\classes-Metals-XL8qEN_nTMOEdX3R1do9Xg==\META-INF\semanticdb\src\main\scala\introcourse\level01\IntroExercises.scala.semanticdb' doesn't exist. There can be many reasons for this error. 
2020.12.04 12:58:22 ERROR code navigation does not work for the file 'C:\Users\User\Documents\projects\intro-to-scala\src\main\scala\introcourse\level01\IntroExercises.scala' because the SemanticDB file 'C:\Users\User\Documents\projects\intro-to-scala\.bloop\intro-to-scala\bloop-bsp-clients-classes\classes-Metals-XL8qEN_nTMOEdX3R1do9Xg==\META-INF\semanticdb\src\main\scala\introcourse\level01\IntroExercises.scala.semanticdb' doesn't exist. There can be many reasons for this error. 
2020.12.04 12:58:28 ERROR code navigation does not work for the file 'C:\Users\User\Documents\projects\intro-to-scala\src\main\scala\introcourse\level01\IntroExercises.scala' because the SemanticDB file 'C:\Users\User\Documents\projects\intro-to-scala\.bloop\intro-to-scala\bloop-bsp-clients-classes\classes-Metals-XL8qEN_nTMOEdX3R1do9Xg==\META-INF\semanticdb\src\main\scala\introcourse\level01\IntroExercises.scala.semanticdb' doesn't exist. There can be many reasons for this error. 
2020.12.04 12:58:44 ERROR code navigation does not work for the file 'C:\Users\User\Documents\projects\intro-to-scala\src\main\scala\introcourse\level01\IntroExercises.scala' because the SemanticDB file 'C:\Users\User\Documents\projects\intro-to-scala\.bloop\intro-to-scala\bloop-bsp-clients-classes\classes-Metals-XL8qEN_nTMOEdX3R1do9Xg==\META-INF\semanticdb\src\main\scala\introcourse\level01\IntroExercises.scala.semanticdb' doesn't exist. There can be many reasons for this error. 
2020.12.04 12:58:46 ERROR code navigation does not work for the file 'C:\Users\User\Documents\projects\intro-to-scala\src\main\scala\introcourse\level01\IntroExercises.scala' because the SemanticDB file 'C:\Users\User\Documents\projects\intro-to-scala\.bloop\intro-to-scala\bloop-bsp-clients-classes\classes-Metals-XL8qEN_nTMOEdX3R1do9Xg==\META-INF\semanticdb\src\main\scala\introcourse\level01\IntroExercises.scala.semanticdb' doesn't exist. There can be many reasons for this error. 
2020.12.04 12:58:46 ERROR code navigation does not work for the file 'C:\Users\User\Documents\projects\intro-to-scala\src\main\scala\introcourse\level01\IntroExercises.scala' because the SemanticDB file 'C:\Users\User\Documents\projects\intro-to-scala\.bloop\intro-to-scala\bloop-bsp-clients-classes\classes-Metals-XL8qEN_nTMOEdX3R1do9Xg==\META-INF\semanticdb\src\main\scala\introcourse\level01\IntroExercises.scala.semanticdb' doesn't exist. There can be many reasons for this error. 
2020.12.04 13:01:00 INFO  compiling intro-to-scala (15 scala sources)
2020.12.04 13:01:11 INFO  time: compiled intro-to-scala in 11s
Dec. 04, 2020 1:07:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 973
Dec. 04, 2020 1:07:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 976
2020.12.04 13:10:14 INFO  compiling intro-to-scala (1 scala source)
2020.12.04 13:10:18 INFO  time: compiled intro-to-scala in 3.68s
2020.12.04 13:13:32 INFO  compiling intro-to-scala (1 scala source)
2020.12.04 13:13:32 INFO  time: compiled intro-to-scala in 0.42s
2020.12.04 13:13:52 INFO  compiling intro-to-scala (1 scala source)
2020.12.04 13:13:52 INFO  time: compiled intro-to-scala in 0.54s
2020.12.04 13:14:01 INFO  compiling intro-to-scala (1 scala source)
2020.12.04 13:14:01 INFO  time: compiled intro-to-scala in 0.41s
2020.12.04 13:14:41 INFO  compiling intro-to-scala (1 scala source)
2020.12.04 13:14:43 INFO  time: compiled intro-to-scala in 2.44s
Dec. 04, 2020 1:14:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1698
2020.12.04 13:16:04 INFO  compiling intro-to-scala (1 scala source)
2020.12.04 13:16:06 INFO  time: compiled intro-to-scala in 2.03s
2020.12.04 13:18:54 INFO  compiling intro-to-scala (1 scala source)
2020.12.04 13:18:56 INFO  time: compiled intro-to-scala in 2.12s
2020.12.05 09:31:53 INFO  Started: Metals version 0.9.7 in workspace 'C:\Users\User\Documents\projects\intro-to-scala' for client vscode.
2020.12.05 09:31:55 INFO  time: initialize in 1.8s
2020.12.05 09:32:00 INFO  Attempting to connect to the build server...
2020.12.05 09:32:00 WARN  no build target for: C:\Users\User\Documents\projects\intro-to-scala\src\main\scala\introcourse\level02\TypesExercises.scala
2020.12.05 09:32:00 WARN  no build target for: C:\Users\User\Documents\projects\intro-to-scala\src\main\scala\introcourse\level01\IntroExercises.scala
2020.12.05 09:32:00 INFO  skipping build import with status 'Installed'
Starting the bsp launcher for bloop...
Opening a bsp server connection with 'bsp --protocol tcp --port 22624'...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
2020.12.05 09:32:04 INFO  no build target: using presentation compiler with only scala-library
Dec. 05, 2020 9:32:04 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6
Dec. 05, 2020 9:32:04 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7
Dec. 05, 2020 9:32:04 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
2020.12.05 09:32:08 WARN  code navigation does not work for the file 'C:\Users\User\Documents\projects\intro-to-scala\src\main\scala\introcourse\level01\IntroExercises.scala' because it doesn't belong to a build target.
2020.12.05 09:32:08 WARN  code navigation does not work for the file 'C:\Users\User\Documents\projects\intro-to-scala\src\main\scala\introcourse\level01\IntroExercises.scala' because it doesn't belong to a build target.
Waiting for the bsp connection to come up...
No server running at 127.0.0.1:8212, let's fire one...
Resolving ch.epfl.scala:bloop-frontend_2.12:1.4.5-6-4768184c...
Starting bloop server at 127.0.0.1:8212...
Attempting a connection to the server...
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Loading 2 projects from 'c:\Users\User\Documents\projects\intro-to-scala\.bloop'...
[0m[32m[D][0m Loading project from 'c:\Users\User\Documents\projects\intro-to-scala\.bloop\intro-to-scala-test.json'
[0m[32m[D][0m Loading project from 'c:\Users\User\Documents\projects\intro-to-scala\.bloop\intro-to-scala.json'
[0m[32m[D][0m Cache miss for scala instance org.scala-lang:scala-compiler:2.13.3.
[0m[32m[D][0m   => C:\Users\User\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\net\java\dev\jna\jna\5.3.1\jna-5.3.1.jar
[0m[32m[D][0m   => C:\Users\User\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\jline\jline\3.15.0\jline-3.15.0.jar
[0m[32m[D][0m   => C:\Users\User\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-compiler\2.13.3\scala-compiler-2.13.3.jar
[0m[32m[D][0m   => C:\Users\User\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-library\2.13.3\scala-library-2.13.3.jar
[0m[32m[D][0m   => C:\Users\User\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-reflect\2.13.3\scala-reflect-2.13.3.jar
[0m[32m[D][0m Configured SemanticDB in projects 'intro-to-scala', 'intro-to-scala-test'
[0m[32m[D][0m Missing analysis file for project 'intro-to-scala-test'
[0m[32m[D][0m Loading previous analysis for 'intro-to-scala' from 'C:\Users\User\Documents\projects\intro-to-scala\target\streams\compile\bloopAnalysisOut\_global\streams\inc_compile_2.13.zip'.
[0m[32m[D][0m Waiting for a connection at 127.0.0.1:22624...
The server is listening for incoming connections at tcp://127.0.0.1:22624...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
2020.12.05 09:32:10 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2020.12.05 09:32:10 INFO  Attempting to connect to the build server...
Starting the bsp launcher for bloop...
2020.12.05 09:32:10 INFO  Attempting to connect to the build server...
Opening a bsp server connection with 'bsp --protocol tcp --port 37323'...
Waiting for the bsp connection to come up...
Starting the bsp launcher for bloop...
Opening a bsp server connection with 'bsp --protocol tcp --port 11433'...
Waiting for the bsp connection to come up...
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Waiting for a connection at 127.0.0.1:37323...
The server is listening for incoming connections at tcp://127.0.0.1:37323...
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Waiting for a connection at 127.0.0.1:11433...
The server is listening for incoming connections at tcp://127.0.0.1:11433...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
2020.12.05 09:32:11 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2020.12.05 09:32:11 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\User\AppData\Local\scalameta\metals\cache\bsp.trace.json
2020.12.05 09:32:11 INFO  time: connected to build server in 11s
2020.12.05 09:32:11 INFO  Connected to Build server v1.4.5-6-4768184c
2020.12.05 09:32:11 INFO  time: imported build in 0.27s
2020.12.05 09:32:18 INFO  time: indexed workspace in 6.33s
2020.12.05 09:33:22 INFO  compiling intro-to-scala (15 scala sources)
2020.12.05 09:33:30 INFO  compiling intro-to-scala-test (13 scala sources)
2020.12.05 09:33:30 INFO  time: compiled intro-to-scala in 8.41s
2020.12.05 09:33:35 INFO  time: compiled intro-to-scala-test in 4.81s
2020.12.05 09:39:40 INFO  compiling intro-to-scala (1 scala source)
2020.12.05 09:39:41 INFO  time: compiled intro-to-scala in 1.05s
2020.12.05 10:24:26 INFO  compiling intro-to-scala (1 scala source)
2020.12.05 10:24:26 INFO  time: compiled intro-to-scala in 0.42s
2020.12.05 10:25:02 INFO  compiling intro-to-scala (1 scala source)
2020.12.05 10:25:03 INFO  time: compiled intro-to-scala in 1.27s
2020.12.05 10:25:32 INFO  compiling intro-to-scala (1 scala source)
2020.12.05 10:25:34 INFO  time: compiled intro-to-scala in 1.33s
2020.12.05 10:26:59 INFO  compiling intro-to-scala (1 scala source)
2020.12.05 10:27:00 INFO  time: compiled intro-to-scala in 1.19s
2020.12.05 10:28:48 INFO  compiling intro-to-scala (1 scala source)
2020.12.05 10:28:48 INFO  time: compiled intro-to-scala in 0.36s
2020.12.05 10:29:24 INFO  compiling intro-to-scala (1 scala source)
2020.12.05 10:29:24 INFO  time: compiled intro-to-scala in 0.13s
2020.12.05 10:30:16 INFO  compiling intro-to-scala (1 scala source)
2020.12.05 10:30:16 INFO  time: compiled intro-to-scala in 92ms
2020.12.05 10:30:28 INFO  compiling intro-to-scala (1 scala source)
2020.12.05 10:30:28 INFO  time: compiled intro-to-scala in 0.12s
2020.12.05 10:30:33 INFO  compiling intro-to-scala (1 scala source)
2020.12.05 10:30:33 INFO  time: compiled intro-to-scala in 81ms
2020.12.05 14:57:39 INFO  compiling intro-to-scala (1 scala source)
2020.12.05 14:57:39 INFO  time: compiled intro-to-scala in 0.3s
2020.12.05 14:59:51 INFO  compiling intro-to-scala (1 scala source)
2020.12.05 14:59:51 INFO  time: compiled intro-to-scala in 0.25s
2020.12.05 15:00:35 INFO  compiling intro-to-scala (1 scala source)
2020.12.05 15:00:35 INFO  time: compiled intro-to-scala in 87ms
2020.12.05 15:06:22 INFO  compiling intro-to-scala (1 scala source)
2020.12.05 15:06:22 INFO  time: compiled intro-to-scala in 0.12s
Dec. 05, 2020 3:06:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 997
2020.12.05 15:07:02 INFO  compiling intro-to-scala (1 scala source)
2020.12.05 15:07:02 INFO  time: compiled intro-to-scala in 90ms
2020.12.05 15:08:37 INFO  compiling intro-to-scala (1 scala source)
2020.12.05 15:08:37 INFO  time: compiled intro-to-scala in 94ms
Dec. 05, 2020 3:09:48 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
2020.12.05 15:10:09 INFO  compiling intro-to-scala (1 scala source)
2020.12.05 15:10:09 INFO  time: compiled intro-to-scala in 0.11s
2020.12.05 15:10:11 INFO  compiling intro-to-scala (1 scala source)
2020.12.05 15:10:11 INFO  time: compiled intro-to-scala in 0.12s
2020.12.05 15:10:30 INFO  compiling intro-to-scala (1 scala source)
2020.12.05 15:10:30 INFO  time: compiled intro-to-scala in 0.25s
2020.12.06 11:20:43 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 11:20:44 INFO  time: compiled intro-to-scala in 1.17s
2020.12.06 11:20:52 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 11:20:54 INFO  time: compiled intro-to-scala in 1.33s
2020.12.06 11:23:35 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 11:23:37 INFO  time: compiled intro-to-scala in 1.21s
2020.12.06 11:24:43 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 11:24:44 INFO  time: compiled intro-to-scala in 1.17s
2020.12.06 11:27:19 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 11:27:19 INFO  time: compiled intro-to-scala in 0.9s
2020.12.06 11:27:30 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 11:27:32 INFO  time: compiled intro-to-scala in 1.14s
2020.12.06 11:31:15 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 11:31:15 INFO  time: compiled intro-to-scala in 0.17s
2020.12.06 11:31:24 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 11:31:24 INFO  time: compiled intro-to-scala in 0.2s
2020.12.06 11:31:45 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 11:31:45 INFO  time: compiled intro-to-scala in 0.13s
2020.12.06 11:31:50 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 11:31:50 INFO  time: compiled intro-to-scala in 0.22s
Dec. 06, 2020 11:31:55 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didFocus(MetalsLanguageServer.scala:934)
	... 16 more

Dec. 06, 2020 11:31:56 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 42,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e s\"The wallet amount is ${wallet.amount}\"\r\n      // case _ \u003d\u003e false\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:32:09 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 43,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \r\n      s\"The wallet amount is ${wallet.amount}\"\r\n      // case _ \u003d\u003e false\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:32:10 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 44,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      s\"The wallet amount is ${wallet.amount}\"\r\n      // case _ \u003d\u003e false\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:32:13 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 45,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      // s\"The wallet amount is ${wallet.amount}\"\r\n      // case _ \u003d\u003e false\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:32:17 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 46,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      // s\"The wallet amount is ${wallet.amount}\"\r\n      case _ \u003d\u003e false\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:32:24 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 47,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      // s\"The wallet amount is ${wallet.amount}\"\r\n      case  \u003d\u003e false\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:32:24 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 48,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      // s\"The wallet amount is ${wallet.amount}\"\r\n      case \u003e \u003d\u003e false\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:32:25 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 49,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      // s\"The wallet amount is ${wallet.amount}\"\r\n      case \u003e0 \u003d\u003e false\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:32:26 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 50,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      // s\"The wallet amount is ${wallet.amount}\"\r\n      case \u003e0  \u003d\u003e false\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

2020.12.06 11:32:26 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 11:32:26 INFO  time: compiled intro-to-scala in 86ms
Dec. 06, 2020 11:32:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 51,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      // s\"The wallet amount is ${wallet.amount}\"\r\n      case \u003e0  \u003d\u003e s\"The wallet amount is ${wallet.amount}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:32:34 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 52,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n\r\n      case \u003e0  \u003d\u003e s\"The wallet amount is ${wallet.amount}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:32:35 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 53,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case \u003e0  \u003d\u003e s\"The wallet amount is ${wallet.amount}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:32:43 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 54,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case \u003e0  \u003d\u003e s\"This is a list of size ${wallet.amount}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:32:47 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 55,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case \u003e0  \u003d\u003e s\"This is a list of size ${x.amount}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:32:47 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 56,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case \u003e0  \u003d\u003e s\"This is a list of size ${xs.amount}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:32:50 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 57,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case \u003e0  \u003d\u003e s\"This is a list of size ${xs.l}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:32:50 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 60,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case \u003e0  \u003d\u003e s\"This is a list of size ${xs.leng}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:32:50 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 61,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case \u003e0  \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:32:54 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 62,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case \u003e 0  \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:33:12 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 63,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case _\u003e 0  \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:33:12 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 64,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case _ \u003e 0  \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

2020.12.06 11:33:13 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 11:33:13 INFO  time: compiled intro-to-scala in 0.13s
Dec. 06, 2020 11:33:35 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 65,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case _\u003e 0  \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:33:36 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 66,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case _\u003e0  \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

2020.12.06 11:33:37 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 11:33:37 INFO  time: compiled intro-to-scala in 0.14s
Dec. 06, 2020 11:33:52 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 67,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case \u003e0  \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:33:56 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 68,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case _\u003e0  \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:33:58 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 69,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case _1\u003e0  \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:34:00 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 70,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case _\u003e0  \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

2020.12.06 11:34:00 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 11:34:00 INFO  time: compiled intro-to-scala in 0.14s
Dec. 06, 2020 11:34:14 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 71,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case \u003e0  \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

2020.12.06 11:34:15 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 11:34:15 INFO  time: compiled intro-to-scala in 93ms
Dec. 06, 2020 11:34:17 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 72,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    xs.length match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case  \u003e0  \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:35:05 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 73,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    (xs.length) match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case  \u003e0  \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:35:08 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 74,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    (xs.length ) match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case  \u003e0  \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:35:08 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 75,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    (xs.length c) match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case  \u003e0  \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:35:08 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 76,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    (xs.length co) match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case  \u003e0  \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:35:09 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 77,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    (xs.length com) match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case  \u003e0  \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:35:09 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 79,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    (xs.length compa) match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case  \u003e0  \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:35:09 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 80,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    (xs.length compar) match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case  \u003e0  \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:35:09 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 81,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    (xs.length compare) match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case  \u003e0  \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:35:09 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 82,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    (xs.length compare ) match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case  \u003e0  \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:35:10 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 83,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    (xs.length compare 1) match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case  \u003e0  \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:35:12 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 84,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    (xs.length compare ) match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case  \u003e0  \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:35:12 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 85,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    (xs.length compare 0) match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case  \u003e0  \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:35:17 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 87,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    (xs.length compare 0) match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case    \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 11:35:17 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 88,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n    (xs.length compare 0) match {\r\n      case 0 \u003d\u003e \"This is an empty list\"\r\n      case  1  \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d ???\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d ???\r\n\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e ???\r\n      case head :: tail \u003d\u003e ???\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d ???\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

2020.12.06 11:35:18 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 11:35:19 INFO  time: compiled intro-to-scala in 1.19s
2020.12.06 11:35:25 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 11:35:25 ERROR 1 deprecation (since 2.13.0); re-run with -deprecation for details
2020.12.06 11:35:25 ERROR No warnings can be incurred under -Werror.
2020.12.06 11:35:25 INFO  time: compiled intro-to-scala in 0.87s
2020.12.06 11:35:34 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 11:35:34 ERROR 1 deprecation (since 2.13.0); re-run with -deprecation for details
2020.12.06 11:35:34 ERROR No warnings can be incurred under -Werror.
2020.12.06 11:35:34 INFO  time: compiled intro-to-scala in 0.86s
2020.12.06 11:36:33 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 11:36:34 ERROR 1 deprecation (since 2.13.0); re-run with -deprecation for details
2020.12.06 11:36:34 ERROR No warnings can be incurred under -Werror.
2020.12.06 11:36:34 INFO  time: compiled intro-to-scala in 1.08s
2020.12.06 11:36:50 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 11:36:50 INFO  time: compiled intro-to-scala in 0.86s
something's wrong: no file:///C:/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala in List[Int]RangePosition(file:///C:/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala, 3469, 3469, 3478)
2020.12.06 11:41:22 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 11:41:22 INFO  time: compiled intro-to-scala in 0.93s
Dec. 06, 2020 11:42:11 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2191
2020.12.06 11:42:26 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 11:42:27 INFO  time: compiled intro-to-scala in 1.06s
Dec. 06, 2020 1:45:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2326
2020.12.06 13:48:23 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 13:48:23 INFO  time: compiled intro-to-scala in 0.22s
Dec. 06, 2020 1:48:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/Int.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\n// DO NOT EDIT, CHANGES WILL BE LOST\n// This auto-generated code can be modified in \"project/GenerateAnyVals.scala\".\n// Afterwards, running \"sbt generateSources\" regenerates this source file.\n\npackage scala\n\n/** `Int`, a 32-bit signed integer (equivalent to Java\u0027s `int` primitive type) is a\n *  subtype of [[scala.AnyVal]]. Instances of `Int` are not\n *  represented by an object in the underlying runtime system.\n *\n *  There is an implicit conversion from [[scala.Int]] \u003d\u003e [[scala.runtime.RichInt]]\n *  which provides useful non-primitive operations.\n */\nfinal abstract class Int private extends AnyVal {\n  def toByte: Byte\n  def toShort: Short\n  def toChar: Char\n  def toInt: Int\n  def toLong: Long\n  def toFloat: Float\n  def toDouble: Double\n\n  /**\n * Returns the bitwise negation of this value.\n * @example {{{\n * ~5 \u003d\u003d -6\n * // in binary: ~00000101 \u003d\u003d\n * //             11111010\n * }}}\n */\n  def unary_~ : Int\n  /** Returns this value, unmodified. */\n  def unary_+ : Int\n  /** Returns the negation of this value. */\n  def unary_- : Int\n\n  def +(x: String): String\n\n  /**\n  * Returns this value bit-shifted left by the specified number of bits,\n  *         filling in the new right bits with zeroes.\n  * @example {{{ 6 \u003c\u003c 3 \u003d\u003d 48 // in binary: 0110 \u003c\u003c 3 \u003d\u003d 0110000 }}}\n  */\n  def \u003c\u003c(x: Int): Int\n  /**\n  * Returns this value bit-shifted left by the specified number of bits,\n  *         filling in the new right bits with zeroes.\n  * @example {{{ 6 \u003c\u003c 3 \u003d\u003d 48 // in binary: 0110 \u003c\u003c 3 \u003d\u003d 0110000 }}}\n  */\n  @deprecated(\"shifting a value by a `Long` argument is deprecated (except when the value is a `Long`).\\nCall `toInt` on the argument to maintain the current behavior and avoid the deprecation warning.\", \"2.12.7\")\n  def \u003c\u003c(x: Long): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling the new left bits with zeroes.\n  * @example {{{ 21 \u003e\u003e\u003e 3 \u003d\u003d 2 // in binary: 010101 \u003e\u003e\u003e 3 \u003d\u003d 010 }}}\n  * @example {{{\n  * -21 \u003e\u003e\u003e 3 \u003d\u003d 536870909\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e\u003e 3 \u003d\u003d\n  * //            00011111 11111111 11111111 11111101\n  * }}}\n  */\n  def \u003e\u003e\u003e(x: Int): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling the new left bits with zeroes.\n  * @example {{{ 21 \u003e\u003e\u003e 3 \u003d\u003d 2 // in binary: 010101 \u003e\u003e\u003e 3 \u003d\u003d 010 }}}\n  * @example {{{\n  * -21 \u003e\u003e\u003e 3 \u003d\u003d 536870909\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e\u003e 3 \u003d\u003d\n  * //            00011111 11111111 11111111 11111101\n  * }}}\n  */\n  @deprecated(\"shifting a value by a `Long` argument is deprecated (except when the value is a `Long`).\\nCall `toInt` on the argument to maintain the current behavior and avoid the deprecation warning.\", \"2.12.7\")\n  def \u003e\u003e\u003e(x: Long): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling in the left bits with the same value as the left-most bit of this.\n  *         The effect of this is to retain the sign of the value.\n  * @example {{{\n  * -21 \u003e\u003e 3 \u003d\u003d -3\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e 3 \u003d\u003d\n  * //            11111111 11111111 11111111 11111101\n  * }}}\n  */\n  def \u003e\u003e(x: Int): Int\n  /**\n  * Returns this value bit-shifted right by the specified number of bits,\n  *         filling in the left bits with the same value as the left-most bit of this.\n  *         The effect of this is to retain the sign of the value.\n  * @example {{{\n  * -21 \u003e\u003e 3 \u003d\u003d -3\n  * // in binary: 11111111 11111111 11111111 11101011 \u003e\u003e 3 \u003d\u003d\n  * //            11111111 11111111 11111111 11111101\n  * }}}\n  */\n  @deprecated(\"shifting a value by a `Long` argument is deprecated (except when the value is a `Long`).\\nCall `toInt` on the argument to maintain the current behavior and avoid the deprecation warning.\", \"2.12.7\")\n  def \u003e\u003e(x: Long): Int\n\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Short): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Char): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Int): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Long): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Float): Boolean\n  /** Returns `true` if this value is equal to x, `false` otherwise. */\n  def \u003d\u003d(x: Double): Boolean\n\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Short): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Char): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Int): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Long): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Float): Boolean\n  /** Returns `true` if this value is not equal to x, `false` otherwise. */\n  def !\u003d(x: Double): Boolean\n\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Byte): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Short): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Char): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Int): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Long): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Float): Boolean\n  /** Returns `true` if this value is less than x, `false` otherwise. */\n  def \u003c(x: Double): Boolean\n\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Short): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Char): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Int): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Long): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Float): Boolean\n  /** Returns `true` if this value is less than or equal to x, `false` otherwise. */\n  def \u003c\u003d(x: Double): Boolean\n\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Byte): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Short): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Char): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Int): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Long): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Float): Boolean\n  /** Returns `true` if this value is greater than x, `false` otherwise. */\n  def \u003e(x: Double): Boolean\n\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Byte): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Short): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Char): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Int): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Long): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Float): Boolean\n  /** Returns `true` if this value is greater than or equal to x, `false` otherwise. */\n  def \u003e\u003d(x: Double): Boolean\n\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Byte): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Short): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Char): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Int): Int\n  /**\n  * Returns the bitwise OR of this value and `x`.\n  * @example {{{\n  * (0xf0 | 0xaa) \u003d\u003d 0xfa\n  * // in binary:   11110000\n  * //            | 10101010\n  * //              --------\n  * //              11111010\n  * }}}\n  */\n  def |(x: Long): Long\n\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Byte): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Short): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Char): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Int): Int\n  /**\n  * Returns the bitwise AND of this value and `x`.\n  * @example {{{\n  * (0xf0 \u0026 0xaa) \u003d\u003d 0xa0\n  * // in binary:   11110000\n  * //            \u0026 10101010\n  * //              --------\n  * //              10100000\n  * }}}\n  */\n  def \u0026(x: Long): Long\n\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Byte): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Short): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Char): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Int): Int\n  /**\n  * Returns the bitwise XOR of this value and `x`.\n  * @example {{{\n  * (0xf0 ^ 0xaa) \u003d\u003d 0x5a\n  * // in binary:   11110000\n  * //            ^ 10101010\n  * //              --------\n  * //              01011010\n  * }}}\n  */\n  def ^(x: Long): Long\n\n  /** Returns the sum of this value and `x`. */\n  def +(x: Byte): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Short): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Char): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Int): Int\n  /** Returns the sum of this value and `x`. */\n  def +(x: Long): Long\n  /** Returns the sum of this value and `x`. */\n  def +(x: Float): Float\n  /** Returns the sum of this value and `x`. */\n  def +(x: Double): Double\n\n  /** Returns the difference of this value and `x`. */\n  def -(x: Byte): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Short): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Char): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Int): Int\n  /** Returns the difference of this value and `x`. */\n  def -(x: Long): Long\n  /** Returns the difference of this value and `x`. */\n  def -(x: Float): Float\n  /** Returns the difference of this value and `x`. */\n  def -(x: Double): Double\n\n  /** Returns the product of this value and `x`. */\n  def *(x: Byte): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Short): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Char): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Int): Int\n  /** Returns the product of this value and `x`. */\n  def *(x: Long): Long\n  /** Returns the product of this value and `x`. */\n  def *(x: Float): Float\n  /** Returns the product of this value and `x`. */\n  def *(x: Double): Double\n\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Byte): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Short): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Char): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Int): Int\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Long): Long\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Float): Float\n  /** Returns the quotient of this value and `x`. */\n  def /(x: Double): Double\n\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Byte): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Short): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Char): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Int): Int\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Long): Long\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Float): Float\n  /** Returns the remainder of the division of this value by `x`. */\n  def %(x: Double): Double\n\n  // Provide a more specific return type for Scaladoc\n  override def getClass(): Class[Int] \u003d ???\n}\n\nobject Int extends AnyValCompanion {\n  /** The smallest value representable as an Int. */\n  final val MinValue \u003d java.lang.Integer.MIN_VALUE\n\n  /** The largest value representable as an Int. */\n  final val MaxValue \u003d java.lang.Integer.MAX_VALUE\n\n  /** Transform a value type into a boxed reference type.\n   *\n   *  Runtime implementation determined by `scala.runtime.BoxesRunTime.boxToInteger`. See [[https://github.com/scala/scala src/library/scala/runtime/BoxesRunTime.java]].\n   *\n   *  @param  x   the Int to be boxed\n   *  @return     a java.lang.Integer offering `x` as its underlying value.\n   */\n  def box(x: Int): java.lang.Integer \u003d ???\n\n  /** Transform a boxed type into a value type.  Note that this\n   *  method is not typesafe: it accepts any Object, but will throw\n   *  an exception if the argument is not a java.lang.Integer.\n   *\n   *  Runtime implementation determined by `scala.runtime.BoxesRunTime.unboxToInt`. See [[https://github.com/scala/scala src/library/scala/runtime/BoxesRunTime.java]].\n   *\n   *  @param  x   the java.lang.Integer to be unboxed.\n   *  @throws     ClassCastException  if the argument is not a java.lang.Integer\n   *  @return     the Int resulting from calling intValue() on `x`\n   */\n  def unbox(x: java.lang.Object): Int \u003d ???\n\n  /** The String representation of the scala.Int companion object. */\n  override def toString \u003d \"object scala.Int\"\n  /** Language mandated coercions from Int to \"wider\" types. */\n  import scala.language.implicitConversions\n  implicit def int2long(x: Int): Long \u003d x.toLong\n  implicit def int2float(x: Int): Float \u003d x.toFloat\n  implicit def int2double(x: Int): Double \u003d x.toDouble\n}\n\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didOpen(MetalsLanguageServer.scala:884)
	... 16 more

2020.12.06 13:48:44 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 13:48:45 INFO  time: compiled intro-to-scala in 1.09s
Dec. 06, 2020 1:50:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/LinearSeq.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala\npackage collection\n\nimport scala.annotation.tailrec\n\n/** Base trait for linearly accessed sequences that have efficient `head` and\n  *  `tail` operations.\n  *  Known subclasses: List, LazyList\n  */\ntrait LinearSeq[+A] extends Seq[A]\n  with LinearSeqOps[A, LinearSeq, LinearSeq[A]]\n  with IterableFactoryDefaults[A, LinearSeq] {\n  override protected[this] def stringPrefix: String \u003d \"LinearSeq\"\n\n  override def iterableFactory: SeqFactory[LinearSeq] \u003d LinearSeq\n}\n\n@SerialVersionUID(3L)\nobject LinearSeq extends SeqFactory.Delegate[LinearSeq](immutable.LinearSeq)\n\n/** Base trait for linear Seq operations */\ntrait LinearSeqOps[+A, +CC[X] \u003c: LinearSeq[X], +C \u003c: LinearSeq[A] with LinearSeqOps[A, CC, C]] extends Any with SeqOps[A, CC, C] {\n\n  // To be overridden in implementations:\n  def isEmpty: Boolean\n  def head: A\n  def tail: C\n\n  override def headOption: Option[A] \u003d\n    if (isEmpty) None else Some(head)\n\n  def iterator: Iterator[A] \u003d\n    if (knownSize \u003d\u003d 0) Iterator.empty\n    else new LinearSeqIterator[A](this)\n\n  def length: Int \u003d {\n    var these \u003d coll\n    var len \u003d 0\n    while (these.nonEmpty) {\n      len +\u003d 1\n      these \u003d these.tail\n    }\n    len\n  }\n\n  override def last: A \u003d {\n    if (isEmpty) throw new NoSuchElementException(\"LinearSeq.last\")\n    else {\n      var these \u003d coll\n      var scout \u003d tail\n      while (scout.nonEmpty) {\n        these \u003d scout\n        scout \u003d scout.tail\n      }\n      these.head\n    }\n  }\n\n  override def lengthCompare(len: Int): Int \u003d {\n    @tailrec def loop(i: Int, xs: LinearSeq[A]): Int \u003d {\n      if (i \u003d\u003d len)\n        if (xs.isEmpty) 0 else 1\n      else if (xs.isEmpty)\n        -1\n      else\n        loop(i + 1, xs.tail)\n    }\n    if (len \u003c 0) 1\n    else loop(0, coll)\n  }\n\n  override def lengthCompare(that: Iterable[_]): Int \u003d {\n    val thatKnownSize \u003d that.knownSize\n\n    if (thatKnownSize \u003e\u003d 0) this lengthCompare thatKnownSize\n    else that match {\n      case that: LinearSeq[_] \u003d\u003e\n        var thisSeq \u003d this\n        var thatSeq \u003d that\n        while (thisSeq.nonEmpty \u0026\u0026 thatSeq.nonEmpty) {\n          thisSeq \u003d thisSeq.tail\n          thatSeq \u003d thatSeq.tail\n        }\n        java.lang.Boolean.compare(thisSeq.nonEmpty, thatSeq.nonEmpty)\n      case _                  \u003d\u003e\n        var thisSeq \u003d this\n        val thatIt \u003d that.iterator\n        while (thisSeq.nonEmpty \u0026\u0026 thatIt.hasNext) {\n          thisSeq \u003d thisSeq.tail\n          thatIt.next()\n        }\n        java.lang.Boolean.compare(thisSeq.nonEmpty, thatIt.hasNext)\n    }\n  }\n\n  override def isDefinedAt(x: Int): Boolean \u003d x \u003e\u003d 0 \u0026\u0026 lengthCompare(x) \u003e 0\n\n  // `apply` is defined in terms of `drop`, which is in turn defined in\n  //  terms of `tail`.\n  @throws[IndexOutOfBoundsException]\n  override def apply(n: Int): A \u003d {\n    if (n \u003c 0) throw new IndexOutOfBoundsException(n.toString)\n    val skipped \u003d drop(n)\n    if (skipped.isEmpty) throw new IndexOutOfBoundsException(n.toString)\n    skipped.head\n  }\n\n  override def foreach[U](f: A \u003d\u003e U): Unit \u003d {\n    var these: LinearSeq[A] \u003d coll\n    while (!these.isEmpty) {\n      f(these.head)\n      these \u003d these.tail\n    }\n  }\n\n  override def forall(p: A \u003d\u003e Boolean): Boolean \u003d {\n    var these: LinearSeq[A] \u003d coll\n    while (!these.isEmpty) {\n      if (!p(these.head)) return false\n      these \u003d these.tail\n    }\n    true\n  }\n\n  override def exists(p: A \u003d\u003e Boolean): Boolean \u003d {\n    var these: LinearSeq[A] \u003d coll\n    while (!these.isEmpty) {\n      if (p(these.head)) return true\n      these \u003d these.tail\n    }\n    false\n  }\n\n  override def contains[A1 \u003e: A](elem: A1): Boolean \u003d {\n    var these: LinearSeq[A] \u003d coll\n    while (!these.isEmpty) {\n      if (these.head \u003d\u003d elem) return true\n      these \u003d these.tail\n    }\n    false\n  }\n\n  override def find(p: A \u003d\u003e Boolean): Option[A] \u003d {\n    var these: LinearSeq[A] \u003d coll\n    while (!these.isEmpty) {\n      if (p(these.head)) return Some(these.head)\n      these \u003d these.tail\n    }\n    None\n  }\n\n  override def foldLeft[B](z: B)(op: (B, A) \u003d\u003e B): B \u003d {\n    var acc \u003d z\n    var these: LinearSeq[A] \u003d coll\n    while (!these.isEmpty) {\n      acc \u003d op(acc, these.head)\n      these \u003d these.tail\n    }\n    acc\n  }\n\n  override def sameElements[B \u003e: A](that: IterableOnce[B]): Boolean \u003d {\n    @tailrec def linearSeqEq(a: LinearSeq[B], b: LinearSeq[B]): Boolean \u003d\n      (a eq b) || {\n        if (a.nonEmpty \u0026\u0026 b.nonEmpty \u0026\u0026 a.head \u003d\u003d b.head) {\n          linearSeqEq(a.tail, b.tail)\n        }\n        else {\n          a.isEmpty \u0026\u0026 b.isEmpty\n        }\n      }\n\n    that match {\n      case that: LinearSeq[B] \u003d\u003e linearSeqEq(coll, that)\n      case _ \u003d\u003e super.sameElements(that)\n    }\n  }\n\n  override def segmentLength(p: A \u003d\u003e Boolean, from: Int): Int \u003d {\n    var i \u003d 0\n    var seq \u003d drop(from)\n    while (seq.nonEmpty \u0026\u0026 p(seq.head)) {\n      i +\u003d 1\n      seq \u003d seq.tail\n    }\n    i\n  }\n\n  override def indexWhere(p: A \u003d\u003e Boolean, from: Int): Int \u003d {\n    var i \u003d math.max(from, 0)\n    var these: LinearSeq[A] \u003d this drop from\n    while (these.nonEmpty) {\n      if (p(these.head))\n        return i\n\n      i +\u003d 1\n      these \u003d these.tail\n    }\n    -1\n  }\n\n  override def lastIndexWhere(p: A \u003d\u003e Boolean, end: Int): Int \u003d {\n    var i \u003d 0\n    var these: LinearSeq[A] \u003d coll\n    var last \u003d -1\n    while (!these.isEmpty \u0026\u0026 i \u003c\u003d end) {\n      if (p(these.head)) last \u003d i\n      these \u003d these.tail\n      i +\u003d 1\n    }\n    last\n  }\n\n  override def findLast(p: A \u003d\u003e Boolean): Option[A] \u003d {\n    var these: LinearSeq[A] \u003d coll\n    var found \u003d false\n    var last: A \u003d null.asInstanceOf[A] // don\u0027t use `Option`, to prevent excessive `Some` allocation\n    while (these.nonEmpty) {\n      val elem \u003d these.head\n      if (p(elem)) {\n        found \u003d true\n        last \u003d elem\n      }\n      these \u003d these.tail\n    }\n    if (found) Some(last) else None\n  }\n\n  override def tails: Iterator[C] \u003d\n    Iterator.iterate(coll)(_.tail).takeWhile(_.nonEmpty) ++ Iterator.single(newSpecificBuilder.result())\n}\n\ntrait StrictOptimizedLinearSeqOps[+A, +CC[X] \u003c: LinearSeq[X], +C \u003c: LinearSeq[A] with StrictOptimizedLinearSeqOps[A, CC, C]] extends Any with LinearSeqOps[A, CC, C] with StrictOptimizedSeqOps[A, CC, C] {\n  // A more efficient iterator implementation than the default LinearSeqIterator\n  override def iterator: Iterator[A] \u003d new AbstractIterator[A] {\n    private[this] var current: Iterable[A] \u003d toIterable\n    def hasNext \u003d !current.isEmpty\n    def next() \u003d { val r \u003d current.head; current \u003d current.tail; r }\n  }\n\n  // Optimized version of `drop` that avoids copying\n  override def drop(n: Int): C \u003d {\n    @tailrec def loop(n: Int, s: C): C \u003d\n      if (n \u003c\u003d 0 || s.isEmpty) s\n      else loop(n - 1, s.tail)\n    loop(n, coll)\n  }\n\n  override def dropWhile(p: A \u003d\u003e Boolean): C \u003d {\n    @tailrec def loop(s: C): C \u003d\n      if (s.nonEmpty \u0026\u0026 p(s.head)) loop(s.tail)\n      else s\n    loop(coll)\n  }\n}\n\n/** A specialized Iterator for LinearSeqs that is lazy enough for Stream and LazyList. This is accomplished by not\n  * evaluating the tail after returning the current head.\n  */\nprivate[collection] final class LinearSeqIterator[A](coll: LinearSeqOps[A, LinearSeq, LinearSeq[A]]) extends AbstractIterator[A] {\n  // A call-by-need cell\n  private[this] final class LazyCell(st: \u003d\u003e LinearSeqOps[A, LinearSeq, LinearSeq[A]]) { lazy val v \u003d st }\n\n  private[this] var these: LazyCell \u003d new LazyCell(coll)\n\n  def hasNext: Boolean \u003d these.v.nonEmpty\n\n  def next(): A \u003d\n    if (isEmpty) Iterator.empty.next()\n    else {\n      val cur    \u003d these.v\n      val result \u003d cur.head\n      these \u003d new LazyCell(cur.tail)\n      result\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didOpen(MetalsLanguageServer.scala:884)
	... 16 more

2020.12.06 13:50:46 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 13:50:46 INFO  time: compiled intro-to-scala in 0.95s
2020.12.06 14:04:14 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 14:04:14 INFO  time: compiled intro-to-scala in 0.94s
2020.12.06 14:04:43 INFO  compiling intro-to-scala-test (1 scala source)
2020.12.06 14:04:44 INFO  time: compiled intro-to-scala-test in 1.13s
Dec. 06, 2020 2:04:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2607
Dec. 06, 2020 2:06:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level01/IntroExercises.scala"
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor21.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didFocus(MetalsLanguageServer.scala:934)
	... 15 more

Dec. 06, 2020 2:06:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/Tuple2.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\n// GENERATED CODE: DO NOT EDIT. See scala.Function0 for timestamp.\n\npackage scala\n\n\n/** A tuple of 2 elements; the canonical representation of a [[scala.Product2]].\n *\n *  @constructor  Create a new tuple with 2 elements. Note that it is more idiomatic to create a Tuple2 via `(t1, t2)`\n *  @param  _1   Element 1 of this Tuple2\n *  @param  _2   Element 2 of this Tuple2\n */\nfinal case class Tuple2[@specialized(Int, Long, Double, Char, Boolean/*, AnyRef*/) +T1, @specialized(Int, Long, Double, Char, Boolean/*, AnyRef*/) +T2](_1: T1, _2: T2)\n  extends Product2[T1, T2]\n{\n  override def toString(): String \u003d \"(\" + _1 + \",\" + _2 + \")\"\n  \n  /** Swaps the elements of this `Tuple`.\n   * @return a new Tuple where the first element is the second element of this Tuple and the\n   * second element is the first element of this Tuple.\n   */\n  def swap: Tuple2[T2,T1] \u003d Tuple2(_2, _1)\n\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didOpen(MetalsLanguageServer.scala:884)
	... 16 more

Dec. 06, 2020 2:06:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor21.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didFocus(MetalsLanguageServer.scala:934)
	... 15 more

Dec. 06, 2020 2:06:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 260,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d persons.foldLeft((acc, cur) \u003d\u003e if (acc. \u003e cur) {\r\n          cur\r\n        } else acc)\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 2:06:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 261,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d persons.foldLeft((acc, cur) \u003d\u003e if (acc._1 \u003e cur) {\r\n          cur\r\n        } else acc)\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 2:06:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 263,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d persons.foldLeft((acc, cur) \u003d\u003e if (acc._2 \u003e cur) {\r\n          cur\r\n        } else acc)\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 2:06:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 264,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d persons.foldLeft((acc, cur) \u003d\u003e if (acc._2 \u003e cur._2) {\r\n          cur\r\n        } else acc)\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 2:06:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 265,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d persons.foldLeft((acc, cur) \u003d\u003e if (acc._2 \u003e cur._2) {\r\n          cur._2\r\n        } else acc)\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 2:06:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 266,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d persons.foldLeft((acc, cur) \u003d\u003e if (acc._2 \u003e cur._2) {\r\n          cur._2\r\n        } else acc._2)\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

2020.12.06 14:06:35 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 14:06:35 INFO  time: compiled intro-to-scala in 0.13s
Dec. 06, 2020 2:06:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 267,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d persons._2.foldLeft((acc, cur) \u003d\u003e if (acc._2 \u003e cur._2) {\r\n          cur._2\r\n        } else acc._2)\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 2:06:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 268,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d persons._2.foldLeft((acc, cur) \u003d\u003e if (acc \u003e cur) {\r\n          cur\r\n        } else acc._2)\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

2020.12.06 14:06:59 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 14:06:59 INFO  time: compiled intro-to-scala in 0.17s
Dec. 06, 2020 2:07:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 269,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d persons.foldLeft((acc, cur) \u003d\u003e if (acc \u003e cur) {\r\n          cur\r\n        } else acc._2)\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

2020.12.06 14:07:06 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 14:07:06 INFO  time: compiled intro-to-scala in 0.16s
Dec. 06, 2020 2:07:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 270,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d persons.foldLeft(((acc, cur) \u003d\u003e if (acc \u003e cur) {\r\n          cur\r\n        } else acc._2)\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 2:07:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 271,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d persons.foldLeft(1((acc, cur) \u003d\u003e if (acc \u003e cur) {\r\n          cur\r\n        } else acc._2)\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 2:07:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 272,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d persons.foldLeft(1)((acc, cur) \u003d\u003e if (acc \u003e cur) {\r\n          cur\r\n        } else acc._2)\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 2:07:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/LinearSeq.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala\npackage collection\n\nimport scala.annotation.tailrec\n\n/** Base trait for linearly accessed sequences that have efficient `head` and\n  *  `tail` operations.\n  *  Known subclasses: List, LazyList\n  */\ntrait LinearSeq[+A] extends Seq[A]\n  with LinearSeqOps[A, LinearSeq, LinearSeq[A]]\n  with IterableFactoryDefaults[A, LinearSeq] {\n  override protected[this] def stringPrefix: String \u003d \"LinearSeq\"\n\n  override def iterableFactory: SeqFactory[LinearSeq] \u003d LinearSeq\n}\n\n@SerialVersionUID(3L)\nobject LinearSeq extends SeqFactory.Delegate[LinearSeq](immutable.LinearSeq)\n\n/** Base trait for linear Seq operations */\ntrait LinearSeqOps[+A, +CC[X] \u003c: LinearSeq[X], +C \u003c: LinearSeq[A] with LinearSeqOps[A, CC, C]] extends Any with SeqOps[A, CC, C] {\n\n  // To be overridden in implementations:\n  def isEmpty: Boolean\n  def head: A\n  def tail: C\n\n  override def headOption: Option[A] \u003d\n    if (isEmpty) None else Some(head)\n\n  def iterator: Iterator[A] \u003d\n    if (knownSize \u003d\u003d 0) Iterator.empty\n    else new LinearSeqIterator[A](this)\n\n  def length: Int \u003d {\n    var these \u003d coll\n    var len \u003d 0\n    while (these.nonEmpty) {\n      len +\u003d 1\n      these \u003d these.tail\n    }\n    len\n  }\n\n  override def last: A \u003d {\n    if (isEmpty) throw new NoSuchElementException(\"LinearSeq.last\")\n    else {\n      var these \u003d coll\n      var scout \u003d tail\n      while (scout.nonEmpty) {\n        these \u003d scout\n        scout \u003d scout.tail\n      }\n      these.head\n    }\n  }\n\n  override def lengthCompare(len: Int): Int \u003d {\n    @tailrec def loop(i: Int, xs: LinearSeq[A]): Int \u003d {\n      if (i \u003d\u003d len)\n        if (xs.isEmpty) 0 else 1\n      else if (xs.isEmpty)\n        -1\n      else\n        loop(i + 1, xs.tail)\n    }\n    if (len \u003c 0) 1\n    else loop(0, coll)\n  }\n\n  override def lengthCompare(that: Iterable[_]): Int \u003d {\n    val thatKnownSize \u003d that.knownSize\n\n    if (thatKnownSize \u003e\u003d 0) this lengthCompare thatKnownSize\n    else that match {\n      case that: LinearSeq[_] \u003d\u003e\n        var thisSeq \u003d this\n        var thatSeq \u003d that\n        while (thisSeq.nonEmpty \u0026\u0026 thatSeq.nonEmpty) {\n          thisSeq \u003d thisSeq.tail\n          thatSeq \u003d thatSeq.tail\n        }\n        java.lang.Boolean.compare(thisSeq.nonEmpty, thatSeq.nonEmpty)\n      case _                  \u003d\u003e\n        var thisSeq \u003d this\n        val thatIt \u003d that.iterator\n        while (thisSeq.nonEmpty \u0026\u0026 thatIt.hasNext) {\n          thisSeq \u003d thisSeq.tail\n          thatIt.next()\n        }\n        java.lang.Boolean.compare(thisSeq.nonEmpty, thatIt.hasNext)\n    }\n  }\n\n  override def isDefinedAt(x: Int): Boolean \u003d x \u003e\u003d 0 \u0026\u0026 lengthCompare(x) \u003e 0\n\n  // `apply` is defined in terms of `drop`, which is in turn defined in\n  //  terms of `tail`.\n  @throws[IndexOutOfBoundsException]\n  override def apply(n: Int): A \u003d {\n    if (n \u003c 0) throw new IndexOutOfBoundsException(n.toString)\n    val skipped \u003d drop(n)\n    if (skipped.isEmpty) throw new IndexOutOfBoundsException(n.toString)\n    skipped.head\n  }\n\n  override def foreach[U](f: A \u003d\u003e U): Unit \u003d {\n    var these: LinearSeq[A] \u003d coll\n    while (!these.isEmpty) {\n      f(these.head)\n      these \u003d these.tail\n    }\n  }\n\n  override def forall(p: A \u003d\u003e Boolean): Boolean \u003d {\n    var these: LinearSeq[A] \u003d coll\n    while (!these.isEmpty) {\n      if (!p(these.head)) return false\n      these \u003d these.tail\n    }\n    true\n  }\n\n  override def exists(p: A \u003d\u003e Boolean): Boolean \u003d {\n    var these: LinearSeq[A] \u003d coll\n    while (!these.isEmpty) {\n      if (p(these.head)) return true\n      these \u003d these.tail\n    }\n    false\n  }\n\n  override def contains[A1 \u003e: A](elem: A1): Boolean \u003d {\n    var these: LinearSeq[A] \u003d coll\n    while (!these.isEmpty) {\n      if (these.head \u003d\u003d elem) return true\n      these \u003d these.tail\n    }\n    false\n  }\n\n  override def find(p: A \u003d\u003e Boolean): Option[A] \u003d {\n    var these: LinearSeq[A] \u003d coll\n    while (!these.isEmpty) {\n      if (p(these.head)) return Some(these.head)\n      these \u003d these.tail\n    }\n    None\n  }\n\n  override def foldLeft[B](z: B)(op: (B, A) \u003d\u003e B): B \u003d {\n    var acc \u003d z\n    var these: LinearSeq[A] \u003d coll\n    while (!these.isEmpty) {\n      acc \u003d op(acc, these.head)\n      these \u003d these.tail\n    }\n    acc\n  }\n\n  override def sameElements[B \u003e: A](that: IterableOnce[B]): Boolean \u003d {\n    @tailrec def linearSeqEq(a: LinearSeq[B], b: LinearSeq[B]): Boolean \u003d\n      (a eq b) || {\n        if (a.nonEmpty \u0026\u0026 b.nonEmpty \u0026\u0026 a.head \u003d\u003d b.head) {\n          linearSeqEq(a.tail, b.tail)\n        }\n        else {\n          a.isEmpty \u0026\u0026 b.isEmpty\n        }\n      }\n\n    that match {\n      case that: LinearSeq[B] \u003d\u003e linearSeqEq(coll, that)\n      case _ \u003d\u003e super.sameElements(that)\n    }\n  }\n\n  override def segmentLength(p: A \u003d\u003e Boolean, from: Int): Int \u003d {\n    var i \u003d 0\n    var seq \u003d drop(from)\n    while (seq.nonEmpty \u0026\u0026 p(seq.head)) {\n      i +\u003d 1\n      seq \u003d seq.tail\n    }\n    i\n  }\n\n  override def indexWhere(p: A \u003d\u003e Boolean, from: Int): Int \u003d {\n    var i \u003d math.max(from, 0)\n    var these: LinearSeq[A] \u003d this drop from\n    while (these.nonEmpty) {\n      if (p(these.head))\n        return i\n\n      i +\u003d 1\n      these \u003d these.tail\n    }\n    -1\n  }\n\n  override def lastIndexWhere(p: A \u003d\u003e Boolean, end: Int): Int \u003d {\n    var i \u003d 0\n    var these: LinearSeq[A] \u003d coll\n    var last \u003d -1\n    while (!these.isEmpty \u0026\u0026 i \u003c\u003d end) {\n      if (p(these.head)) last \u003d i\n      these \u003d these.tail\n      i +\u003d 1\n    }\n    last\n  }\n\n  override def findLast(p: A \u003d\u003e Boolean): Option[A] \u003d {\n    var these: LinearSeq[A] \u003d coll\n    var found \u003d false\n    var last: A \u003d null.asInstanceOf[A] // don\u0027t use `Option`, to prevent excessive `Some` allocation\n    while (these.nonEmpty) {\n      val elem \u003d these.head\n      if (p(elem)) {\n        found \u003d true\n        last \u003d elem\n      }\n      these \u003d these.tail\n    }\n    if (found) Some(last) else None\n  }\n\n  override def tails: Iterator[C] \u003d\n    Iterator.iterate(coll)(_.tail).takeWhile(_.nonEmpty) ++ Iterator.single(newSpecificBuilder.result())\n}\n\ntrait StrictOptimizedLinearSeqOps[+A, +CC[X] \u003c: LinearSeq[X], +C \u003c: LinearSeq[A] with StrictOptimizedLinearSeqOps[A, CC, C]] extends Any with LinearSeqOps[A, CC, C] with StrictOptimizedSeqOps[A, CC, C] {\n  // A more efficient iterator implementation than the default LinearSeqIterator\n  override def iterator: Iterator[A] \u003d new AbstractIterator[A] {\n    private[this] var current: Iterable[A] \u003d toIterable\n    def hasNext \u003d !current.isEmpty\n    def next() \u003d { val r \u003d current.head; current \u003d current.tail; r }\n  }\n\n  // Optimized version of `drop` that avoids copying\n  override def drop(n: Int): C \u003d {\n    @tailrec def loop(n: Int, s: C): C \u003d\n      if (n \u003c\u003d 0 || s.isEmpty) s\n      else loop(n - 1, s.tail)\n    loop(n, coll)\n  }\n\n  override def dropWhile(p: A \u003d\u003e Boolean): C \u003d {\n    @tailrec def loop(s: C): C \u003d\n      if (s.nonEmpty \u0026\u0026 p(s.head)) loop(s.tail)\n      else s\n    loop(coll)\n  }\n}\n\n/** A specialized Iterator for LinearSeqs that is lazy enough for Stream and LazyList. This is accomplished by not\n  * evaluating the tail after returning the current head.\n  */\nprivate[collection] final class LinearSeqIterator[A](coll: LinearSeqOps[A, LinearSeq, LinearSeq[A]]) extends AbstractIterator[A] {\n  // A call-by-need cell\n  private[this] final class LazyCell(st: \u003d\u003e LinearSeqOps[A, LinearSeq, LinearSeq[A]]) { lazy val v \u003d st }\n\n  private[this] var these: LazyCell \u003d new LazyCell(coll)\n\n  def hasNext: Boolean \u003d these.v.nonEmpty\n\n  def next(): A \u003d\n    if (isEmpty) Iterator.empty.next()\n    else {\n      val cur    \u003d these.v\n      val result \u003d cur.head\n      these \u003d new LazyCell(cur.tail)\n      result\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didOpen(MetalsLanguageServer.scala:884)
	... 16 more

2020.12.06 14:07:36 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 14:07:36 INFO  time: compiled intro-to-scala in 0.15s
2020.12.06 14:07:56 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 14:07:56 INFO  time: compiled intro-to-scala in 0.16s
2020.12.06 14:07:58 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 14:07:58 INFO  time: compiled intro-to-scala in 0.15s
2020.12.06 14:08:10 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 14:08:10 INFO  time: compiled intro-to-scala in 0.19s
Dec. 06, 2020 2:13:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/package.scala"
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor21.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didFocus(MetalsLanguageServer.scala:934)
	... 15 more

Dec. 06, 2020 2:13:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor21.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didFocus(MetalsLanguageServer.scala:934)
	... 15 more

Dec. 06, 2020 2:14:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 284,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n  \r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d persons.foldLeft(1)((acc, cur) \u003d\u003e if (acc._2 \u003e cur._2) {\r\n          cur._2\r\n        } else acc._2)\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 2:14:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 285,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d persons.foldLeft(1)((acc, cur) \u003d\u003e if (acc._2 \u003e cur._2) {\r\n          cur._2\r\n        } else acc._2)\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 2:14:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 286,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d   nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

2020.12.06 14:14:15 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 14:14:15 INFO  time: compiled intro-to-scala in 0.17s
Dec. 06, 2020 2:14:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 287,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(: List[Person]): Person \u003d   nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 2:14:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 288,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(: List[Person]): Person \u003d   nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 2:14:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 290,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(: List[Person]): Person \u003d\u003e?   nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 2:14:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 291,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(: List[Person]): Person \u003d\u003e   nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 2:14:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 295,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(: List[Person]): Person \u003d\u003e    match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 2:14:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 296,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(: List[Person]): Person \u003d\u003e   p match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 2:14:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 297,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(: List[Person]): Person \u003d\u003e   pe match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 2:14:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 298,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(: List[Person]): Person \u003d\u003e   per match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 2:14:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 299,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(: List[Person]): Person \u003d\u003e   person match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d ???\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d ???\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 06, 2020 2:14:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/package.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\n/**\n * Core Scala types. They are always available without an explicit import.\n * @contentDiagram hideNodes \"scala.Serializable\"\n */\npackage object scala {\n  type Throwable \u003d java.lang.Throwable\n  type Exception \u003d java.lang.Exception\n  type Error     \u003d java.lang.Error\n\n  type RuntimeException                \u003d java.lang.RuntimeException\n  type NullPointerException            \u003d java.lang.NullPointerException\n  type ClassCastException              \u003d java.lang.ClassCastException\n  type IndexOutOfBoundsException       \u003d java.lang.IndexOutOfBoundsException\n  type ArrayIndexOutOfBoundsException  \u003d java.lang.ArrayIndexOutOfBoundsException\n  type StringIndexOutOfBoundsException \u003d java.lang.StringIndexOutOfBoundsException\n  type UnsupportedOperationException   \u003d java.lang.UnsupportedOperationException\n  type IllegalArgumentException        \u003d java.lang.IllegalArgumentException\n  type NoSuchElementException          \u003d java.util.NoSuchElementException\n  type NumberFormatException           \u003d java.lang.NumberFormatException\n  type AbstractMethodError             \u003d java.lang.AbstractMethodError\n  type InterruptedException            \u003d java.lang.InterruptedException\n\n  // A dummy used by the specialization annotation.\n  val AnyRef \u003d new Specializable {\n    override def toString \u003d \"object AnyRef\"\n  }\n\n  type TraversableOnce[+A] \u003d scala.collection.TraversableOnce[A]\n\n  type Traversable[+A] \u003d scala.collection.Traversable[A]\n  val Traversable \u003d scala.collection.Traversable\n\n  type Iterable[+A] \u003d scala.collection.Iterable[A]\n  val Iterable \u003d scala.collection.Iterable\n\n  type Seq[+A] \u003d scala.collection.Seq[A]\n  val Seq \u003d scala.collection.Seq\n\n  type IndexedSeq[+A] \u003d scala.collection.IndexedSeq[A]\n  val IndexedSeq \u003d scala.collection.IndexedSeq\n\n  type Iterator[+A] \u003d scala.collection.Iterator[A]\n  val Iterator \u003d scala.collection.Iterator\n\n  type BufferedIterator[+A] \u003d scala.collection.BufferedIterator[A]\n\n  type List[+A] \u003d scala.collection.immutable.List[A]\n  val List \u003d scala.collection.immutable.List\n\n  val Nil \u003d scala.collection.immutable.Nil\n\n  type ::[A] \u003d scala.collection.immutable.::[A]\n  val :: \u003d scala.collection.immutable.::\n\n  val +: \u003d scala.collection.+:\n  val :+ \u003d scala.collection.:+\n\n  type Stream[+A] \u003d scala.collection.immutable.Stream[A]\n  val Stream \u003d scala.collection.immutable.Stream\n  val #:: \u003d scala.collection.immutable.Stream.#::\n\n  type Vector[+A] \u003d scala.collection.immutable.Vector[A]\n  val Vector \u003d scala.collection.immutable.Vector\n\n  type StringBuilder \u003d scala.collection.mutable.StringBuilder\n  val StringBuilder \u003d scala.collection.mutable.StringBuilder\n\n  type Range \u003d scala.collection.immutable.Range\n  val Range \u003d scala.collection.immutable.Range\n\n  // Numeric types which were moved into scala.math.*\n\n  type BigDecimal \u003d scala.math.BigDecimal\n  val BigDecimal \u003d scala.math.BigDecimal\n\n  type BigInt \u003d scala.math.BigInt\n  val BigInt \u003d scala.math.BigInt\n\n  type Equiv[T] \u003d scala.math.Equiv[T]\n  val Equiv \u003d scala.math.Equiv\n\n  type Fractional[T] \u003d scala.math.Fractional[T]\n  val Fractional \u003d scala.math.Fractional\n\n  type Integral[T] \u003d scala.math.Integral[T]\n  val Integral \u003d scala.math.Integral\n\n  type Numeric[T] \u003d scala.math.Numeric[T]\n  val Numeric \u003d scala.math.Numeric\n\n  type Ordered[T] \u003d scala.math.Ordered[T]\n  val Ordered \u003d scala.math.Ordered\n\n  type Ordering[T] \u003d scala.math.Ordering[T]\n  val Ordering \u003d scala.math.Ordering\n\n  type PartialOrdering[T] \u003d scala.math.PartialOrdering[T]\n  type PartiallyOrdered[T] \u003d scala.math.PartiallyOrdered[T]\n\n  type Either[+A, +B] \u003d scala.util.Either[A, B]\n  val Either \u003d scala.util.Either\n\n  type Left[+A, +B] \u003d scala.util.Left[A, B]\n  val Left \u003d scala.util.Left\n\n  type Right[+A, +B] \u003d scala.util.Right[A, B]\n  val Right \u003d scala.util.Right\n\n  // Annotations which we might move to annotation.*\n/*\n  type SerialVersionUID \u003d annotation.SerialVersionUID\n  type deprecated \u003d annotation.deprecated\n  type deprecatedName \u003d annotation.deprecatedName\n  type inline \u003d annotation.inline\n  type native \u003d annotation.native\n  type noinline \u003d annotation.noinline\n  type remote \u003d annotation.remote\n  type specialized \u003d annotation.specialized\n  type transient \u003d annotation.transient\n  type throws  \u003d annotation.throws\n  type unchecked \u003d annotation.unchecked.unchecked\n  type volatile \u003d annotation.volatile\n  */\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didOpen(MetalsLanguageServer.scala:884)
	... 16 more

2020.12.06 14:14:29 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 14:14:29 INFO  time: compiled intro-to-scala in 82ms
Dec. 06, 2020 2:14:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3194
2020.12.06 14:15:15 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 14:15:15 INFO  time: compiled intro-to-scala in 0.17s
2020.12.06 14:16:15 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 14:16:15 INFO  time: compiled intro-to-scala in 0.14s
2020.12.06 14:16:25 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 14:16:25 INFO  time: compiled intro-to-scala in 0.94s
2020.12.06 15:25:45 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 15:25:45 INFO  time: compiled intro-to-scala in 93ms
something's wrong: no file:///C:/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala in List[introcourse.level03.Person]RangePosition(file:///C:/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala, 6084, 6084, 6096)
Dec. 06, 2020 4:52:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3744
Dec. 06, 2020 4:52:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala\npackage collection\npackage immutable\n\nimport generic._\nimport mutable.{Builder, ListBuffer}\nimport scala.annotation.tailrec\nimport java.io.{ObjectOutputStream, ObjectInputStream}\n\n/** A class for immutable linked lists representing ordered collections\n *  of elements of type `A`.\n *\n *  This class comes with two implementing case classes `scala.Nil`\n *  and `scala.::` that implement the abstract members `isEmpty`,\n *  `head` and `tail`.\n *\n *  This class is optimal for last-in-first-out (LIFO), stack-like access patterns. If you need another access\n *  pattern, for example, random access or FIFO, consider using a collection more suited to this than `List`.\n *\n *  $usesMutableState\n *\n *  \u003d\u003dPerformance\u003d\u003d\n *  \u0027\u0027\u0027Time:\u0027\u0027\u0027 `List` has `O(1)` prepend and head/tail access. Most other operations are `O(n)` on the number of elements in the list.\n *  This includes the index-based lookup of elements, `length`, `append` and `reverse`.\n *\n *  \u0027\u0027\u0027Space:\u0027\u0027\u0027 `List` implements \u0027\u0027\u0027structural sharing\u0027\u0027\u0027 of the tail list. This means that many operations are either\n *  zero- or constant-memory cost.\n *  {{{\n *  val mainList \u003d List(3, 2, 1)\n *  val with4 \u003d    4 :: mainList  // re-uses mainList, costs one :: instance\n *  val with42 \u003d   42 :: mainList // also re-uses mainList, cost one :: instance\n *  val shorter \u003d  mainList.tail  // costs nothing as it uses the same 2::1::Nil instances as mainList\n *  }}}\n *\n *  @example {{{\n *  // Make a list via the companion object factory\n *  val days \u003d List(\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\")\n *\n *  // Make a list element-by-element\n *  val when \u003d \"AM\" :: \"PM\" :: List()\n *\n *  // Pattern match\n *  days match {\n *    case firstDay :: otherDays \u003d\u003e\n *      println(\"The first day of the week is: \" + firstDay)\n *    case List() \u003d\u003e\n *      println(\"There don\u0027t seem to be any week days.\")\n *  }\n *  }}}\n *\n *  @note The functional list is characterized by persistence and structural sharing, thus offering considerable\n *        performance and space consumption benefits in some scenarios if used correctly.\n *        However, note that objects having multiple references into the same functional list (that is,\n *        objects that rely on structural sharing), will be serialized and deserialized with multiple lists, one for\n *        each reference to it. I.e. structural sharing is lost after serialization/deserialization.\n *\n *  @author  Martin Odersky and others\n *  @since   1.0\n *  @see  [[http://docs.scala-lang.org/overviews/collections/concrete-immutable-collection-classes.html#lists \"Scala\u0027s Collection Library overview\"]]\n *  section on `Lists` for more information.\n *\n *  @define coll list\n *  @define Coll `List`\n *  @define thatinfo the class of the returned collection. In the standard library configuration,\n *    `That` is always `List[B]` because an implicit of type `CanBuildFrom[List, B, That]`\n *    is defined in object `List`.\n *  @define bfinfo an implicit value of class `CanBuildFrom` which determines the\n *    result class `That` from the current representation type `Repr`\n *    and the new element type `B`. This is usually the `canBuildFrom` value\n *    defined in object `List`.\n *  @define orderDependent\n *  @define orderDependentFold\n *  @define mayNotTerminateInf\n *  @define willNotTerminateInf\n */\n@SerialVersionUID(-6084104484083858598L) // value computed by serialver for 2.11.2, annotation added in 2.11.4\nsealed abstract class List[+A] extends AbstractSeq[A]\n                                  with LinearSeq[A]\n                                  with Product\n                                  with GenericTraversableTemplate[A, List]\n                                  with LinearSeqOptimized[A, List[A]]\n                                  with scala.Serializable {\n  override def companion: GenericCompanion[List] \u003d List\n\n  def isEmpty: Boolean\n  def head: A\n  def tail: List[A]\n\n  // New methods in List\n\n  /** Adds an element at the beginning of this list.\n   *  @param x the element to prepend.\n   *  @return  a list which contains `x` as first element and\n   *           which continues with this list.\n   *\n   *  @usecase def ::(x: A): List[A]\n   *    @inheritdoc\n   *\n   *    Example:\n   *    {{{1 :: List(2, 3) \u003d List(2, 3).::(1) \u003d List(1, 2, 3)}}}\n   */\n  def ::[B \u003e: A] (x: B): List[B] \u003d\n    new scala.collection.immutable.::(x, this)\n\n  /** Adds the elements of a given list in front of this list.\n   *  @param prefix  The list elements to prepend.\n   *  @return a list resulting from the concatenation of the given\n   *    list `prefix` and this list.\n   *\n   *  @usecase def :::(prefix: List[A]): List[A]\n   *    @inheritdoc\n   *\n   *    Example:\n   *    {{{List(1, 2) ::: List(3, 4) \u003d List(3, 4).:::(List(1, 2)) \u003d List(1, 2, 3, 4)}}}\n   */\n  def :::[B \u003e: A](prefix: List[B]): List[B] \u003d\n    if (isEmpty) prefix\n    else if (prefix.isEmpty) this\n    else (new ListBuffer[B] ++\u003d prefix).prependToList(this)\n\n  /** Adds the elements of a given list in reverse order in front of this list.\n   *  `xs reverse_::: ys` is equivalent to\n   *  `xs.reverse ::: ys` but is more efficient.\n   *\n   *  @param prefix the prefix to reverse and then prepend\n   *  @return       the concatenation of the reversed prefix and the current list.\n   *\n   *  @usecase def reverse_:::(prefix: List[A]): List[A]\n   *    @inheritdoc\n   */\n  def reverse_:::[B \u003e: A](prefix: List[B]): List[B] \u003d {\n    var these: List[B] \u003d this\n    var pres \u003d prefix\n    while (!pres.isEmpty) {\n      these \u003d pres.head :: these\n      pres \u003d pres.tail\n    }\n    these\n  }\n\n  /** Builds a new list by applying a function to all elements of this list.\n   *  Like `xs map f`, but returns `xs` unchanged if function\n   *  `f` maps all elements to themselves (as determined by `eq`).\n   *\n   *  @param f      the function to apply to each element.\n   *  @tparam B     the element type of the returned collection.\n   *  @return       a list resulting from applying the given function\n   *                `f` to each element of this list and collecting the results.\n   *\n   *  @usecase def mapConserve(f: A \u003d\u003e A): List[A]\n   *    @inheritdoc\n   */\n  @inline final def mapConserve[B \u003e: A \u003c: AnyRef](f: A \u003d\u003e B): List[B] \u003d {\n    // Note to developers: there exists a duplication between this function and `reflect.internal.util.Collections#map2Conserve`.\n    // If any successful optimization attempts or other changes are made, please rehash them there too.\n    @tailrec\n    def loop(mappedHead: List[B] \u003d Nil, mappedLast: ::[B], unchanged: List[A], pending: List[A]): List[B] \u003d\n    if (pending.isEmpty) {\n      if (mappedHead eq null) unchanged\n      else {\n        mappedLast.tl \u003d unchanged\n        mappedHead\n      }\n    }\n    else {\n      val head0 \u003d pending.head\n      val head1 \u003d f(head0)\n\n      if (head1 eq head0.asInstanceOf[AnyRef])\n        loop(mappedHead, mappedLast, unchanged, pending.tail)\n      else {\n        var xc \u003d unchanged\n        var mappedHead1: List[B] \u003d mappedHead\n        var mappedLast1: ::[B] \u003d mappedLast\n        while (xc ne pending) {\n          val next \u003d new ::[B](xc.head, Nil)\n          if (mappedHead1 eq null) mappedHead1 \u003d next\n          if (mappedLast1 ne null) mappedLast1.tl \u003d next\n          mappedLast1 \u003d next\n          xc \u003d xc.tail\n        }\n        val next \u003d new ::(head1, Nil)\n        if (mappedHead1 eq null) mappedHead1 \u003d next\n        if (mappedLast1 ne null) mappedLast1.tl \u003d next\n        mappedLast1 \u003d next\n        val tail0 \u003d pending.tail\n        loop(mappedHead1, mappedLast1, tail0, tail0)\n\n      }\n    }\n    loop(null, null, this, this)\n  }\n\n  // Overridden methods from IterableLike and SeqLike or overloaded variants of such methods\n\n  override def ++[B \u003e: A, That](that: GenTraversableOnce[B])(implicit bf: CanBuildFrom[List[A], B, That]): That \u003d\n    if (bf eq List.ReusableCBF) (this ::: that.seq.toList).asInstanceOf[That]\n    else super.++(that)\n\n  override def +:[B \u003e: A, That](elem: B)(implicit bf: CanBuildFrom[List[A], B, That]): That \u003d bf match {\n    case _: List.GenericCanBuildFrom[_] \u003d\u003e (elem :: this).asInstanceOf[That]\n    case _ \u003d\u003e super.+:(elem)(bf)\n  }\n\n  override def toList: List[A] \u003d this\n\n  override def take(n: Int): List[A] \u003d if (isEmpty || n \u003c\u003d 0) Nil else {\n    val h \u003d new ::(head, Nil)\n    var t \u003d h\n    var rest \u003d tail\n    var i \u003d 1\n    while ({if (rest.isEmpty) return this; i \u003c n}) {\n      i +\u003d 1\n      val nx \u003d new ::(rest.head, Nil)\n      t.tl \u003d nx\n      t \u003d nx\n      rest \u003d rest.tail\n    }\n    h\n  }\n\n  override def drop(n: Int): List[A] \u003d {\n    var these \u003d this\n    var count \u003d n\n    while (!these.isEmpty \u0026\u0026 count \u003e 0) {\n      these \u003d these.tail\n      count -\u003d 1\n    }\n    these\n  }\n\n  /**\n   *  @example {{{\n   *  // Given a list\n   *  val letters \u003d List(\u0027a\u0027,\u0027b\u0027,\u0027c\u0027,\u0027d\u0027,\u0027e\u0027)\n   *\n   *  // `slice` returns all elements beginning at index `from` and afterwards,\n   *  // up until index `until` (excluding index `until`.)\n   *  letters.slice(1,3) // Returns List(\u0027b\u0027,\u0027c\u0027)\n   *  }}}\n   */\n  override def slice(from: Int, until: Int): List[A] \u003d {\n    val lo \u003d scala.math.max(from, 0)\n    if (until \u003c\u003d lo || isEmpty) Nil\n    else this drop lo take (until - lo)\n  }\n\n  override def takeRight(n: Int): List[A] \u003d {\n    @tailrec\n    def loop(lead: List[A], lag: List[A]): List[A] \u003d lead match {\n      case Nil \u003d\u003e lag\n      case _ :: tail \u003d\u003e loop(tail, lag.tail)\n    }\n    loop(drop(n), this)\n  }\n\n  // dropRight is inherited from LinearSeq\n\n  override def splitAt(n: Int): (List[A], List[A]) \u003d {\n    val b \u003d new ListBuffer[A]\n    var i \u003d 0\n    var these \u003d this\n    while (!these.isEmpty \u0026\u0026 i \u003c n) {\n      i +\u003d 1\n      b +\u003d these.head\n      these \u003d these.tail\n    }\n    (b.toList, these)\n  }\n\n  final override def map[B, That](f: A \u003d\u003e B)(implicit bf: CanBuildFrom[List[A], B, That]): That \u003d {\n    if (bf eq List.ReusableCBF) {\n      if (this eq Nil) Nil.asInstanceOf[That] else {\n        val h \u003d new ::[B](f(head), Nil)\n        var t: ::[B] \u003d h\n        var rest \u003d tail\n        while (rest ne Nil) {\n          val nx \u003d new ::(f(rest.head), Nil)\n          t.tl \u003d nx\n          t \u003d nx\n          rest \u003d rest.tail\n        }\n        h.asInstanceOf[That]\n      }\n    }\n    else super.map(f)\n  }\n\n  final override def collect[B, That](pf: PartialFunction[A, B])(implicit bf: CanBuildFrom[List[A], B, That]): That \u003d {\n    if (bf eq List.ReusableCBF) {\n      if (this eq Nil) Nil.asInstanceOf[That] else {\n        var rest \u003d this\n        var h: ::[B] \u003d null\n        // Special case for first element\n        do {\n          val x: Any \u003d pf.applyOrElse(rest.head, List.partialNotApplied)\n          if (x.asInstanceOf[AnyRef] ne List.partialNotApplied) h \u003d new ::(x.asInstanceOf[B], Nil)\n          rest \u003d rest.tail\n          if (rest eq Nil) return (if (h eq null ) Nil else h).asInstanceOf[That]\n        } while (h eq null)\n        var t \u003d h\n        // Remaining elements\n        do {\n          val x: Any \u003d pf.applyOrElse(rest.head, List.partialNotApplied)\n          if (x.asInstanceOf[AnyRef] ne List.partialNotApplied) {\n            val nx \u003d new ::(x.asInstanceOf[B], Nil)\n            t.tl \u003d nx\n            t \u003d nx\n          }\n          rest \u003d rest.tail\n        } while (rest ne Nil)\n        h.asInstanceOf[That]\n      }\n    }\n    else super.collect(pf)\n  }\n\n  final override def flatMap[B, That](f: A \u003d\u003e GenTraversableOnce[B])(implicit bf: CanBuildFrom[List[A], B, That]): That \u003d {\n    if (bf eq List.ReusableCBF) {\n      if (this eq Nil) Nil.asInstanceOf[That] else {\n        var rest \u003d this\n        var found \u003d false\n        var h: ::[B] \u003d null\n        var t: ::[B] \u003d null\n        while (rest ne Nil) {\n          f(rest.head).seq.foreach{ b \u003d\u003e\n            if (!found) {\n              h \u003d new ::(b, Nil)\n              t \u003d h\n              found \u003d true\n            }\n            else {\n              val nx \u003d new ::(b, Nil)\n              t.tl \u003d nx\n              t \u003d nx\n            }\n          }\n          rest \u003d rest.tail\n        }\n        (if (!found) Nil else h).asInstanceOf[That]\n      }\n    }\n    else super.flatMap(f)\n  }\n\n  @inline final override def takeWhile(p: A \u003d\u003e Boolean): List[A] \u003d {\n    val b \u003d new ListBuffer[A]\n    var these \u003d this\n    while (!these.isEmpty \u0026\u0026 p(these.head)) {\n      b +\u003d these.head\n      these \u003d these.tail\n    }\n    b.toList\n  }\n\n  @inline final override def dropWhile(p: A \u003d\u003e Boolean): List[A] \u003d {\n    @tailrec\n    def loop(xs: List[A]): List[A] \u003d\n      if (xs.isEmpty || !p(xs.head)) xs\n      else loop(xs.tail)\n\n    loop(this)\n  }\n\n  @inline final override def span(p: A \u003d\u003e Boolean): (List[A], List[A]) \u003d {\n    val b \u003d new ListBuffer[A]\n    var these \u003d this\n    while (!these.isEmpty \u0026\u0026 p(these.head)) {\n      b +\u003d these.head\n      these \u003d these.tail\n    }\n    (b.toList, these)\n  }\n\n  // Overridden with an implementation identical to the inherited one (at this time)\n  // solely so it can be finalized and thus inlinable.\n  @inline final override def foreach[U](f: A \u003d\u003e U) {\n    var these \u003d this\n    while (!these.isEmpty) {\n      f(these.head)\n      these \u003d these.tail\n    }\n  }\n\n  override def reverse: List[A] \u003d {\n    var result: List[A] \u003d Nil\n    var these \u003d this\n    while (!these.isEmpty) {\n      result \u003d these.head :: result\n      these \u003d these.tail\n    }\n    result\n  }\n\n  override def foldRight[B](z: B)(op: (A, B) \u003d\u003e B): B \u003d\n    reverse.foldLeft(z)((right, left) \u003d\u003e op(left, right))\n\n  override def stringPrefix \u003d \"List\"\n\n  override def toStream : Stream[A] \u003d\n    if (isEmpty) Stream.Empty\n    else new Stream.Cons(head, tail.toStream)\n\n  // Create a proxy for Java serialization that allows us to avoid mutation\n  // during deserialization.  This is the Serialization Proxy Pattern.\n  protected final def writeReplace(): AnyRef \u003d new List.SerializationProxy(this)\n}\n\n/** The empty list.\n *\n *  @author  Martin Odersky\n *  @since   2.8\n */\n@SerialVersionUID(0 - 8256821097970055419L)\ncase object Nil extends List[Nothing] {\n  override def isEmpty \u003d true\n  override def head: Nothing \u003d\n    throw new NoSuchElementException(\"head of empty list\")\n  override def tail: List[Nothing] \u003d\n    throw new UnsupportedOperationException(\"tail of empty list\")\n  // Removal of equals method here might lead to an infinite recursion similar to IntMap.equals.\n  override def equals(that: Any) \u003d that match {\n    case that1: scala.collection.GenSeq[_] \u003d\u003e that1.isEmpty\n    case _ \u003d\u003e false\n  }\n}\n\n/** A non empty list characterized by a head and a tail.\n *  @param head the first element of the list\n *  @param tl   the list containing the remaining elements of this list after the first one.\n *  @tparam B   the type of the list elements.\n *  @author  Martin Odersky\n *  @since   2.8\n */\n@SerialVersionUID(509929039250432923L) // value computed by serialver for 2.11.2, annotation added in 2.11.4\nfinal case class ::[B](override val head: B, private[scala] var tl: List[B]) extends List[B] {\n  override def tail : List[B] \u003d tl\n  override def isEmpty: Boolean \u003d false\n}\n\n/** $factoryInfo\n *  @define coll list\n *  @define Coll `List`\n */\nobject List extends SeqFactory[List] {\n  /** $genericCanBuildFromInfo */\n  implicit def canBuildFrom[A]: CanBuildFrom[Coll, A, List[A]] \u003d\n    ReusableCBF.asInstanceOf[GenericCanBuildFrom[A]]\n\n  def newBuilder[A]: Builder[A, List[A]] \u003d new ListBuffer[A]\n\n  override def empty[A]: List[A] \u003d Nil\n\n  override def apply[A](xs: A*): List[A] \u003d xs.toList\n\n  private[collection] val partialNotApplied \u003d new Function1[Any, Any] { def apply(x: Any): Any \u003d this }\n\n  @SerialVersionUID(1L)\n  private class SerializationProxy[A](@transient private var orig: List[A]) extends Serializable {\n\n    private def writeObject(out: ObjectOutputStream) {\n      out.defaultWriteObject()\n      var xs: List[A] \u003d orig\n      while (!xs.isEmpty) {\n        out.writeObject(xs.head)\n        xs \u003d xs.tail\n      }\n      out.writeObject(ListSerializeEnd)\n    }\n\n    // Java serialization calls this before readResolve during deserialization.\n    // Read the whole list and store it in `orig`.\n    private def readObject(in: ObjectInputStream) {\n      in.defaultReadObject()\n      val builder \u003d List.newBuilder[A]\n      while (true) in.readObject match {\n        case ListSerializeEnd \u003d\u003e\n          orig \u003d builder.result()\n          return\n        case a \u003d\u003e\n          builder +\u003d a.asInstanceOf[A]\n      }\n    }\n\n    // Provide the result stored in `orig` for Java serialization\n    private def readResolve(): AnyRef \u003d orig\n  }\n}\n\n/** Only used for list serialization */\n@SerialVersionUID(0L - 8476791151975527571L)\nprivate[scala] case object ListSerializeEnd\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didOpen(MetalsLanguageServer.scala:884)
	... 16 more

2020.12.06 16:52:57 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 16:52:58 INFO  time: compiled intro-to-scala in 1.15s
Dec. 06, 2020 4:52:58 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
Dec. 06, 2020 4:55:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/test/scala/introcourse/level03/ListExercisesTest.scala",
      "languageId": "scala",
      "version": 1,
      "text": "package introcourse.level03\r\n\r\nimport introcourse.level03.ListExercises._\r\nimport org.scalactic.TypeCheckedTripleEquals\r\nimport org.scalatest.funspec.AnyFunSpec\r\n\r\nclass ListExercisesTest extends AnyFunSpec with TypeCheckedTripleEquals {\r\n\r\n  describe(\"prependToList\") {\r\n\r\n    it(\"should add an element to the start of the List\") {\r\n      val list \u003d prependToList(1, List(2, 3, 4))\r\n      assert(list \u003d\u003d\u003d List(1, 2, 3, 4))\r\n    }\r\n\r\n  }\r\n\r\n  describe(\"appendToList\") {\r\n\r\n    it(\"should add an element to the end of the List\") {\r\n      val list \u003d appendToList(1, List(2, 3, 4))\r\n      assert(list \u003d\u003d\u003d List(2, 3, 4, 1))\r\n    }\r\n\r\n  }\r\n\r\n  describe(\"isEmptyList\") {\r\n\r\n    it(\"should return True for Nil\") {\r\n      assert(isEmptyList(Nil) \u003d\u003d\u003d true)\r\n    }\r\n\r\n    it(\"should return False for non-empty List\") {\r\n      assert(isEmptyList(1 :: 2 :: Nil) \u003d\u003d\u003d false)\r\n    }\r\n\r\n  }\r\n\r\n  describe(\"showListSize\") {\r\n\r\n    it(\"should show size for Nil\") {\r\n      assert(showListSize(Nil) \u003d\u003d\u003d \"This is an empty list\")\r\n    }\r\n\r\n    it(\"should show size for non-empty List\") {\r\n      assert(showListSize(1 :: 2 :: 3 :: Nil) \u003d\u003d\u003d \"This is a list of size 3\")\r\n    }\r\n\r\n  }\r\n\r\n  describe(\"addNumToEach\") {\r\n\r\n    it(\"should return Nil given Nil\") {\r\n      assert(addNumToEach(5, Nil) \u003d\u003d\u003d Nil)\r\n    }\r\n\r\n    it(\"should add 5 to each element of non-empty List\") {\r\n      assert(addNumToEach(5, List(1, 2, 3)) \u003d\u003d\u003d List(6, 7, 8))\r\n    }\r\n\r\n  }\r\n\r\n  describe(\"filterEven\") {\r\n\r\n    it(\"should return even numbers\") {\r\n      assert(filterEven(List(1, 2, 3, 4, 5, 6)) \u003d\u003d List(2, 4, 6))\r\n    }\r\n\r\n  }\r\n\r\n  describe(\"product\") {\r\n\r\n    it(\"should return 1 given Nil\") {\r\n      assert(product(Nil) \u003d\u003d\u003d 1)\r\n    }\r\n\r\n    it(\"should multiply all the elements of non-empty List\") {\r\n      assert(product(List(2, 5, 3)) \u003d\u003d\u003d 30)\r\n    }\r\n  }\r\n\r\n  describe(\"min\") {\r\n\r\n    it(\"should return smallest Int given Nil\") {\r\n      assert(min(Nil) \u003d\u003d\u003d Int.MinValue)\r\n    }\r\n\r\n    it(\"should return smallest number in non-empty List\") {\r\n      assert(min(List(4, 6, 1)) \u003d\u003d\u003d 1)\r\n    }\r\n\r\n  }\r\n\r\n  describe(\"youngestPerson\") {\r\n\r\n    it(\"should return a silly default person given Nil\") {\r\n      assert(youngestPerson(Nil) \u003d\u003d\u003d Person(\"Nobody\", 0))\r\n    }\r\n\r\n    it(\"should return the first person in the list with the smallest age given a non-empty List\") {\r\n      val youngest \u003d Person(\"Karen Page\", 27)\r\n\r\n      assert(youngestPerson(peopleList) \u003d\u003d\u003d youngest)\r\n    }\r\n\r\n  }\r\n\r\n  describe(\"personWithIndex\") {\r\n\r\n    it(\"should return each person with their 1-based index\") {\r\n      assert(personWithIndex(peopleList) \u003d\u003d\u003d (\r\n        List((Person(\"Matt Murdock\",            30), 1),\r\n             (Person(\"Karen Page\",              27), 2),\r\n             (Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31), 3),\r\n             (Person(\"Claire Temple\",           32), 4),\r\n             (Person(\"Wilson Fisk\",             42), 5),\r\n             (Person(\"Elektra Natchios\",        27), 6)))\r\n      )\r\n    }\r\n  }\r\n\r\n  describe(\"showEveryNthPerson\") {\r\n\r\n    it(\"should show every Nth person\") {\r\n      val people \u003d ListExercises.peopleList\r\n      val all \u003d people.map(showPerson)\r\n\r\n      assert(showEveryNthPerson(-5, people) \u003d\u003d\u003d all)\r\n      assert(showEveryNthPerson(0, people)  \u003d\u003d\u003d all)\r\n      assert(showEveryNthPerson(1, people)  \u003d\u003d\u003d all)\r\n      assert(showEveryNthPerson(2, people)  \u003d\u003d\u003d List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\"))\r\n      assert(showEveryNthPerson(3, people)  \u003d\u003d\u003d List(\"Franklin \u0027Foggy\u0027 Nelson is 31 years old\", \"Elektra Natchios is 27 years old\"))\r\n      assert(showEveryNthPerson(5, people)  \u003d\u003d\u003d List(\"Wilson Fisk is 42 years old\"))\r\n      assert(showEveryNthPerson(6, people)  \u003d\u003d\u003d List(\"Elektra Natchios is 27 years old\"))\r\n      assert(showEveryNthPerson(8, people)  \u003d\u003d\u003d Nil)\r\n    }\r\n  }\r\n\r\n  describe(\"getNames\") {\r\n\r\n    it(\"should return the names of all persons\") {\r\n      val powerRangers \u003d List(Person(\"Red Ranger\", 22), Person(\"Yellow Ranger\", 20), Person(\"Pink Ranger\", 21))\r\n      val names \u003d getNames(powerRangers)\r\n      assert(names \u003d\u003d\u003d List(\"Red Ranger\", \"Yellow Ranger\", \"Pink Ranger\"))\r\n    }\r\n\r\n  }\r\n\r\n  describe(\"getAdults\") {\r\n\r\n    it(\"should return persons aged \u003e\u003d 18\") {\r\n      val powerRangers \u003d List(Person(\"Red Ranger\", 17), Person(\"Yellow Ranger\", 18), Person(\"Pink Ranger\", 19))\r\n      val adults \u003d getAdults(powerRangers)\r\n      assert(adults \u003d\u003d\u003d List(Person(\"Yellow Ranger\", 18), Person(\"Pink Ranger\", 19)))\r\n    }\r\n\r\n  }\r\n\r\n  describe(\"reverseList\") {\r\n\r\n    it(\"should return the input list reversed\") {\r\n      val inputList \u003d List(1, 2, 3)\r\n      val result \u003d reverseList(inputList)\r\n      assert(result \u003d\u003d\u003d List(3, 2, 1))\r\n    }\r\n\r\n  }\r\n\r\n  describe(\"sublists\") {\r\n\r\n    it(\"should pack consecutive duplicates of list elements into sublists\") {\r\n      val inputList \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n      val result \u003d sublists(inputList)\r\n      assert(result \u003d\u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\")))\r\n    }\r\n\r\n  }\r\n\r\n}\r\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didOpen(MetalsLanguageServer.scala:884)
	... 16 more

2020.12.06 16:57:28 INFO  compiling intro-to-scala (1 scala source)
2020.12.06 16:57:28 INFO  time: compiled intro-to-scala in 0.21s
Dec. 07, 2020 8:13:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor21.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didFocus(MetalsLanguageServer.scala:934)
	... 15 more

Dec. 07, 2020 8:15:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 548,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0)\r\n  { return Nil }\r\n  else if( ){}\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:15:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 549,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0)\r\n  { return Nil }\r\n  else if( n){}\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:15:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 550,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0)\r\n  { return Nil }\r\n  else if( n ){}\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:15:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 551,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0)\r\n  { return Nil }\r\n  else if( n \u003e){}\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:15:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 552,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0)\r\n  { return Nil }\r\n  else if( n \u003e ){}\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:15:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 553,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0)\r\n  { return Nil }\r\n  else if( n \u003e p){}\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:15:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 554,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0)\r\n  { return Nil }\r\n  else if( n \u003e pe){}\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:15:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 555,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0)\r\n  { return Nil }\r\n  else if( n \u003e per){}\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:15:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 557,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0)\r\n  { return Nil }\r\n  else if( n \u003e perso){}\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:15:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 558,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0)\r\n  { return Nil }\r\n  else if( n \u003e persons){}\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:15:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 559,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0)\r\n  { return Nil }\r\n  else if( n \u003e persons.){}\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:15:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 560,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0)\r\n  { return Nil }\r\n  else if( n \u003e persons.l){}\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:15:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 561,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0)\r\n  { return Nil }\r\n  else if( n \u003e persons.le){}\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:15:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 565,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0)\r\n  { return Nil }\r\n  else if( n \u003e persons.length){}\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

something's wrong: no file:///C:/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala in List[introcourse.level03.Person]RangePosition(file:///C:/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala, 6753, 6753, 6765)
Dec. 07, 2020 8:16:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 566,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0)\r\n  { return Nil }\r\n  else if( n \u003e persons.length){\r\n    \r\n  }\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:16:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 568,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0){ return Nil }\r\n  else if( n \u003e persons.length){\r\n\r\n  }\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:16:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 569,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0){ \r\n    return Nil }\r\n  else if( n \u003e persons.length){\r\n\r\n  }\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:16:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 570,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0){ \r\n    return Nil \r\n  }\r\n  else if( n \u003e persons.length){\r\n\r\n  }\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:16:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 571,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0){ \r\n    return Nil \r\n  }\r\n  else if( n \u003e persons.length){\r\n    \r\n  }\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:16:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 572,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0){ \r\n    return Nil \r\n  }\r\n  else if( n \u003e persons.length){\r\n    r\r\n  }\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:16:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 573,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0){ \r\n    return Nil \r\n  }\r\n  else if( n \u003e persons.length){\r\n    re\r\n  }\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:16:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 574,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0){ \r\n    return Nil \r\n  }\r\n  else if( n \u003e persons.length){\r\n    ret\r\n  }\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:16:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 575,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0){ \r\n    return Nil \r\n  }\r\n  else if( n \u003e persons.length){\r\n    retu\r\n  }\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:16:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 578,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0){ \r\n    return Nil \r\n  }\r\n  else if( n \u003e persons.length){\r\n    return \r\n  }\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:16:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 579,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0){ \r\n    return Nil \r\n  }\r\n  else if( n \u003e persons.length){\r\n    return ()\r\n  }\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:16:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 580,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0){ \r\n    persons.map(showPerson)\r\n  }\r\n  else if( n \u003e persons.length){\r\n    return ()\r\n  }\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:16:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 581,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0){ \r\n    persons.map(showPerson)\r\n  }\r\n  else if( n \u003e persons.length){\r\n   N\r\n  }\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:16:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 582,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0){ \r\n    persons.map(showPerson)\r\n  }\r\n  else if( n \u003e persons.length){\r\n   Ni\r\n  }\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:16:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 583,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0){ \r\n    persons.map(showPerson)\r\n  }\r\n  else if( n \u003e persons.length){\r\n   Nil\r\n  }\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:16:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 584,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0){ \r\n    persons.map(showPerson)\r\n  }\r\n  else if ( n \u003e persons.length){\r\n   Nil\r\n  }\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:16:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 585,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d\u003c0){ \r\n    persons.map(showPerson)\r\n  }\r\n  else if( n \u003e persons.length){\r\n   Nil\r\n  }\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:16:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 586,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003d0){ \r\n    persons.map(showPerson)\r\n  }\r\n  else if( n \u003e persons.length){\r\n   Nil\r\n  }\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:16:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 587,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n 0){ \r\n    persons.map(showPerson)\r\n  }\r\n  else if( n \u003e persons.length){\r\n   Nil\r\n  }\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:16:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 588,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003c0){ \r\n    persons.map(showPerson)\r\n  }\r\n  else if( n \u003e persons.length){\r\n   Nil\r\n  }\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:16:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 589,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003c\u003d0){ \r\n    persons.map(showPerson)\r\n  }\r\n  else if( n \u003e persons.length){\r\n   Nil\r\n  }\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 07, 2020 8:17:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 590,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003c\u003d 0){ \r\n    persons.map(showPerson)\r\n  }\r\n  else if( n \u003e persons.length){\r\n   Nil\r\n  }\r\n  else\r\n  }\r\n\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

2020.12.07 20:17:00 INFO  compiling intro-to-scala (1 scala source)
2020.12.07 20:17:00 INFO  time: compiled intro-to-scala in 0.23s
2020.12.07 20:17:21 INFO  compiling intro-to-scala (1 scala source)
2020.12.07 20:17:21 INFO  time: compiled intro-to-scala in 0.15s
Dec. 07, 2020 8:17:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 591,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level03\r\n\r\n/**\r\n  * These exercises will teach you how to work with the `List` data structure in Scala in a declarative manner.\r\n  * At the end of these exercises, you should have a good intuition on when to use `map`, `filter` or `fold`.\r\n  */\r\nobject ListExercises {\r\n\r\n  /**\r\n    * A `List` in Scala is a linked list.\r\n    *\r\n    * sealed trait List[+A]\r\n    * case class ::[A](head: A, tail: List[A]) extends List[A]\r\n    * case object Nil extends List[Nothing]\r\n    *\r\n    * You can create a List using the `::` constructor as such:\r\n    *\r\n    * scala\u003e `::`(1, `::`(2, `::`(3, Nil))) // backticks to use :: in prefix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e (1 :: (2 :: (3 :: Nil))) // no need for backticks to use :: in infix position\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * scala\u003e 1 :: 2 :: 3 :: Nil\r\n    * \u003e List(1, 2, 3)\r\n    *\r\n    * Often times, the `List.apply` static method is more convenient:\r\n    *\r\n    * scala\u003e List.apply(1, 2, 3)\r\n    *\r\n    * The `apply` method in any object is the default method, so you can leave it out when using it:\r\n    *\r\n    * scala\u003e List(1, 2, 3)\r\n    */\r\n\r\n  /**\r\n    * scala\u003e prependToList(1, List(2, 3, 4))\r\n    * \u003e List(1,2,3,4)\r\n    *\r\n    * Hint: Refer the construction of list\r\n    */\r\n  def prependToList[A](x: A, xs: List[A]): List[A] \u003d x :: xs\r\n\r\n  /**\r\n    * scala\u003e appendToList(1, List(2, 3, 4))\r\n    * \u003e List(2,3,4,1)\r\n    *\r\n    * Hint: Use the :+ operator\r\n    */\r\n  def appendToList[A](x: A, xs: List[A]): List[A] \u003d {\r\n    xs :+ x\r\n  }\r\n\r\n  /**\r\n    * `List` has an `.isEmpty` method that you can call to know whether an instance is empty or not.\r\n    *\r\n    * For this exercise, let\u0027s build a version of `isEmpty` called `isEmptyList` without using `.isEmpty` (that would be cheating!).\r\n    *\r\n    * scala\u003e isEmptyList(Nil)\r\n    * \u003e true\r\n    *\r\n    * scala\u003e isEmptyList(List(1, 2, 3))\r\n    * \u003e false\r\n    *\r\n    * Hint: Use pattern matching. You can pattern match on `List` using its two constructors `::` and `Nil` as such:\r\n    *\r\n    * ```\r\n    * list match {\r\n    * case head :: tail \u003d\u003e // do something for non-empty list\r\n    * case Nil \u003d\u003e // do something for empty list\r\n    * }\r\n    * ```\r\n    */\r\n  def isEmptyList[A](xs: List[A]): Boolean \u003d {\r\n    xs match {\r\n      case Nil \u003d\u003e true\r\n      case _ :: _ \u003d\u003e false\r\n    }\r\n  }\r\n\r\n  /**\r\n    * scala\u003e showListSize(List(1, 2, 3))\r\n    * \u003e \"This is a list of size 3\"\r\n    *\r\n    * scala\u003e showListSize(List(\"ABC\"))\r\n    * \u003e \"This is a list of size 1\"\r\n    *\r\n    * scala\u003e showListSize(Nil)\r\n    * \u003e \"This is an empty list\"\r\n    *\r\n    * Hint: Use pattern matching, string interpolation and length\r\n    */\r\n  def showListSize[A](xs: List[A]): String \u003d { \r\n   xs match {\r\n      case Nil \u003d\u003e \"This is an empty list\"\r\n      case _ :: _ \u003d\u003e s\"This is a list of size ${xs.length}\"\r\n    }\r\n}\r\n  /**\r\n    * Mapping a function over a List\r\n    *\r\n    * This is typically what you want if the initial List and the resulting List\r\n    * are of the same size.\r\n    *\r\n    * scala\u003e addNumToEach(10, List(1, 2, 3))\r\n    * \u003e List(11, 12, 13)\r\n    *\r\n    * Hint: Use .map\r\n    **/\r\n  def addNumToEach(num: Int, nums: List[Int]): List[Int] \u003d   { nums.map(\r\n      number \u003d\u003e number + num\r\n    )}\r\n\r\n  /**\r\n    * Filter a List\r\n    *\r\n    * This is typically what you want if the size of the resulting List is \u003c\u003d that of the initial.\r\n    *\r\n    * scala\u003e filterEven(List(1, 2, 3, 4))\r\n    * \u003e List(2, 4)\r\n    *\r\n    * Hint: Use .filter and \u0027%\u0027 for mod operator\r\n    */\r\n  def filterEven(nums: List[Int]): List[Int] \u003d {\r\n    nums.filter(num\u003d\u003e num%2\u003d\u003d0)\r\n  }\r\n\r\n  /**\r\n    * Folds\r\n    *\r\n    * A fold is an operation over a data structure to yield a summary value.\r\n    *\r\n    * The next 3 exercises are to practise folding.\r\n    *\r\n    * Examples: sum, product, min, max\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n\r\n  /**\r\n    * scala\u003e product(List(2, 5, 3))\r\n    * \u003e 30\r\n    *\r\n    * https://en.wikipedia.org/wiki/Empty_product\r\n    * scala\u003e product(Nil)\r\n    * \u003e 1\r\n    *\r\n    * Hint: Use .foldLeft\r\n    */\r\n  def product(nums: List[Int]): Int \u003d nums.foldLeft(1)((acc, cur) \u003d\u003e acc * cur)\r\n  /**\r\n    * scala\u003e min(List(4, 6, 1))\r\n    * \u003e 1\r\n    *\r\n    * scala\u003e min(Nil)\r\n    * \u003e Int.MinValue\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    **/\r\n  def min(nums: List[Int]): Int \u003d\r\n    nums match {\r\n      case Nil \u003d\u003e Integer.MIN_VALUE\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc \u003e cur) {\r\n          cur\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  private[level03] val peopleList \u003d\r\n    List(Person(\"Matt Murdock\", 30),\r\n      Person(\"Karen Page\", 27),\r\n      Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31),\r\n      Person(\"Claire Temple\", 32),\r\n      Person(\"Wilson Fisk\", 42),\r\n      Person(\"Elektra Natchios\", 27)\r\n    )\r\n\r\n  /**\r\n    * Return the person in the List that is the youngest. If there are more than one person with the youngest age,\r\n    * return the first one.\r\n    *\r\n    * scala\u003e youngestPerson(peopleList)\r\n    * \u003e Person(\"Karen Page\", 27)\r\n    *\r\n    * scala\u003e youngestPerson(Nil)\r\n    * \u003e Person(\"Nobody\", 0)\r\n    *\r\n    * Hint: Use pattern matching and .foldLeft\r\n    */\r\n  def youngestPerson(persons: List[Person]): Person \u003d \r\n    persons match {\r\n      case Nil \u003d\u003e Person(\"Nobody\", 0)\r\n      case head :: tail \u003d\u003e tail.foldLeft(head)((acc, cur) \u003d\u003e\r\n        if (acc.age \u003c\u003d cur.age) {\r\n          acc\r\n        } else acc\r\n      )\r\n    }\r\n\r\n  /**\r\n    * Return a list of pairs of a Person and their position in the `peopleList`.\r\n    * The position should be a 1-based index.\r\n    *\r\n    * You can pattern match on pairs inside a lambda function, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).map {\r\n    *   case (str, num) \u003d\u003e // do something with `str` and `num`\r\n    * }\r\n    * ```\r\n    *\r\n    * Otherwise, you\u0027ll need to use `._1` and `._2` methods to access the fields in the pair, e.g.\r\n    *\r\n    * ```\r\n    * List((\"abc\", 1), (\"def\", 2)).filter(pair \u003d\u003e // do something with `pair._1` and `pair._2`)\r\n    * ```\r\n    *\r\n    * Hint: Use `zipWithIndex`\r\n    */\r\n  def personWithIndex(people: List[Person]): List[(Person, Int)] \u003d people.zipWithIndex.map{\r\n      case (person, index) \u003d\u003e (person, index + 1)\r\n    }\r\n\r\n  /**\r\n    * Log every nth person from the `peopleList` given an index `n`.\r\n    *\r\n    * scala\u003e showEveryNthPerson(2, peopleList)\r\n    * \u003e List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\")\r\n    *\r\n    * Validation rules:\r\n    *\r\n    * If `n` is zero or less then return the full List\r\n    * If `n` is greater than the length of the list then return an empty List\r\n    *\r\n    * Hint: Use `personWithIndex`, `filter` and `showPerson`.\r\n    *\r\n    */\r\n  def showEveryNthPerson(n: Int, persons: List[Person]): List[String] \u003d {\r\n  if(n \u003c\u003d 0){ \r\n    persons.map(showPerson)\r\n  }\r\n  else if( n \u003e persons.length){\r\n   Nil\r\n  }\r\n  else{\r\n      val filteredPersons: List[(Person, Int)] \u003d\r\n        personWithIndex(persons).filter {\r\n          case (_, index) \u003d\u003e index % n \u003d\u003d 0\r\n        }\r\n      filteredPersons.map { case (person, index) \u003d\u003e showPerson(person) }\r\n    }\r\n  }\r\n  private[level03] def showPerson(person: Person): String \u003d\r\n    person match {\r\n      case Person(a, b) \u003d\u003e s\"$a is $b years old\"\r\n    }\r\n\r\n  /**\r\n    * Bonus exercises!\r\n    */\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getNames(persons: List[Person]): List[String] \u003d {\r\n    var names: List[String] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      names \u003d names :+ person.name\r\n    }\r\n    names\r\n  }\r\n\r\n  /**\r\n    * Rewrite this function that uses a mutable variable and for-loop in an immutable fashion\r\n    *\r\n    * Return people aged \u003e\u003d 18\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def getAdults(persons: List[Person]): List[Person] \u003d {\r\n    var adults: List[Person] \u003d Nil\r\n    for (person \u003c- persons) {\r\n      if (person.age \u003e\u003d 18)\r\n        adults \u003d adults :+ person\r\n    }\r\n    adults\r\n  }\r\n\r\n\r\n  /**\r\n    * Rewrite this function that uses mutable variables and for-loop in an immutable fashion\r\n    *\r\n    * Don\u0027t use `.reverse` because that\u0027s cheating ;)\r\n    */\r\n  @SuppressWarnings(Array(\"org.wartremover.warts.Var\"))\r\n  def reverseList[A](xs: List[A]): List[A] \u003d {\r\n    var result: List[A] \u003d Nil\r\n    for (x \u003c- xs) {\r\n      result \u003d x :: result\r\n    }\r\n    result\r\n  }\r\n\r\n  /**\r\n    * Pack consecutive duplicates of list elements into sublists.\r\n    * If a list contains repeated elements they should be placed in separate sublists.\r\n    *\r\n    * Given: val l1 \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n    * sublists(l1) \u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\"))\r\n    */\r\n  def sublists[A](xs: List[A]): List[List[A]] \u003d ???\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

2020.12.07 20:17:25 INFO  compiling intro-to-scala (1 scala source)
Dec. 07, 2020 8:17:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/test/scala/introcourse/level03/ListExercisesTest.scala",
      "languageId": "scala",
      "version": 1,
      "text": "package introcourse.level03\r\n\r\nimport introcourse.level03.ListExercises._\r\nimport org.scalactic.TypeCheckedTripleEquals\r\nimport org.scalatest.funspec.AnyFunSpec\r\n\r\nclass ListExercisesTest extends AnyFunSpec with TypeCheckedTripleEquals {\r\n\r\n  describe(\"prependToList\") {\r\n\r\n    it(\"should add an element to the start of the List\") {\r\n      val list \u003d prependToList(1, List(2, 3, 4))\r\n      assert(list \u003d\u003d\u003d List(1, 2, 3, 4))\r\n    }\r\n\r\n  }\r\n\r\n  describe(\"appendToList\") {\r\n\r\n    it(\"should add an element to the end of the List\") {\r\n      val list \u003d appendToList(1, List(2, 3, 4))\r\n      assert(list \u003d\u003d\u003d List(2, 3, 4, 1))\r\n    }\r\n\r\n  }\r\n\r\n  describe(\"isEmptyList\") {\r\n\r\n    it(\"should return True for Nil\") {\r\n      assert(isEmptyList(Nil) \u003d\u003d\u003d true)\r\n    }\r\n\r\n    it(\"should return False for non-empty List\") {\r\n      assert(isEmptyList(1 :: 2 :: Nil) \u003d\u003d\u003d false)\r\n    }\r\n\r\n  }\r\n\r\n  describe(\"showListSize\") {\r\n\r\n    it(\"should show size for Nil\") {\r\n      assert(showListSize(Nil) \u003d\u003d\u003d \"This is an empty list\")\r\n    }\r\n\r\n    it(\"should show size for non-empty List\") {\r\n      assert(showListSize(1 :: 2 :: 3 :: Nil) \u003d\u003d\u003d \"This is a list of size 3\")\r\n    }\r\n\r\n  }\r\n\r\n  describe(\"addNumToEach\") {\r\n\r\n    it(\"should return Nil given Nil\") {\r\n      assert(addNumToEach(5, Nil) \u003d\u003d\u003d Nil)\r\n    }\r\n\r\n    it(\"should add 5 to each element of non-empty List\") {\r\n      assert(addNumToEach(5, List(1, 2, 3)) \u003d\u003d\u003d List(6, 7, 8))\r\n    }\r\n\r\n  }\r\n\r\n  describe(\"filterEven\") {\r\n\r\n    it(\"should return even numbers\") {\r\n      assert(filterEven(List(1, 2, 3, 4, 5, 6)) \u003d\u003d List(2, 4, 6))\r\n    }\r\n\r\n  }\r\n\r\n  describe(\"product\") {\r\n\r\n    it(\"should return 1 given Nil\") {\r\n      assert(product(Nil) \u003d\u003d\u003d 1)\r\n    }\r\n\r\n    it(\"should multiply all the elements of non-empty List\") {\r\n      assert(product(List(2, 5, 3)) \u003d\u003d\u003d 30)\r\n    }\r\n  }\r\n\r\n  describe(\"min\") {\r\n\r\n    it(\"should return smallest Int given Nil\") {\r\n      assert(min(Nil) \u003d\u003d\u003d Int.MinValue)\r\n    }\r\n\r\n    it(\"should return smallest number in non-empty List\") {\r\n      assert(min(List(4, 6, 1)) \u003d\u003d\u003d 1)\r\n    }\r\n\r\n  }\r\n\r\n  describe(\"youngestPerson\") {\r\n\r\n    it(\"should return a silly default person given Nil\") {\r\n      assert(youngestPerson(Nil) \u003d\u003d\u003d Person(\"Nobody\", 0))\r\n    }\r\n\r\n    it(\"should return the first person in the list with the smallest age given a non-empty List\") {\r\n      val youngest \u003d Person(\"Karen Page\", 27)\r\n\r\n      assert(youngestPerson(peopleList) \u003d\u003d\u003d youngest)\r\n    }\r\n\r\n  }\r\n\r\n  describe(\"personWithIndex\") {\r\n\r\n    it(\"should return each person with their 1-based index\") {\r\n      assert(personWithIndex(peopleList) \u003d\u003d\u003d (\r\n        List((Person(\"Matt Murdock\",            30), 1),\r\n             (Person(\"Karen Page\",              27), 2),\r\n             (Person(\"Franklin \u0027Foggy\u0027 Nelson\", 31), 3),\r\n             (Person(\"Claire Temple\",           32), 4),\r\n             (Person(\"Wilson Fisk\",             42), 5),\r\n             (Person(\"Elektra Natchios\",        27), 6)))\r\n      )\r\n    }\r\n  }\r\n\r\n  describe(\"showEveryNthPerson\") {\r\n\r\n    it(\"should show every Nth person\") {\r\n      val people \u003d ListExercises.peopleList\r\n      val all \u003d people.map(showPerson)\r\n\r\n      assert(showEveryNthPerson(-5, people) \u003d\u003d\u003d all)\r\n      assert(showEveryNthPerson(0, people)  \u003d\u003d\u003d all)\r\n      assert(showEveryNthPerson(1, people)  \u003d\u003d\u003d all)\r\n      assert(showEveryNthPerson(2, people)  \u003d\u003d\u003d List(\"Karen Page is 27 years old\", \"Claire Temple is 32 years old\", \"Elektra Natchios is 27 years old\"))\r\n      assert(showEveryNthPerson(3, people)  \u003d\u003d\u003d List(\"Franklin \u0027Foggy\u0027 Nelson is 31 years old\", \"Elektra Natchios is 27 years old\"))\r\n      assert(showEveryNthPerson(5, people)  \u003d\u003d\u003d List(\"Wilson Fisk is 42 years old\"))\r\n      assert(showEveryNthPerson(6, people)  \u003d\u003d\u003d List(\"Elektra Natchios is 27 years old\"))\r\n      assert(showEveryNthPerson(8, people)  \u003d\u003d\u003d Nil)\r\n    }\r\n  }\r\n\r\n  describe(\"getNames\") {\r\n\r\n    it(\"should return the names of all persons\") {\r\n      val powerRangers \u003d List(Person(\"Red Ranger\", 22), Person(\"Yellow Ranger\", 20), Person(\"Pink Ranger\", 21))\r\n      val names \u003d getNames(powerRangers)\r\n      assert(names \u003d\u003d\u003d List(\"Red Ranger\", \"Yellow Ranger\", \"Pink Ranger\"))\r\n    }\r\n\r\n  }\r\n\r\n  describe(\"getAdults\") {\r\n\r\n    it(\"should return persons aged \u003e\u003d 18\") {\r\n      val powerRangers \u003d List(Person(\"Red Ranger\", 17), Person(\"Yellow Ranger\", 18), Person(\"Pink Ranger\", 19))\r\n      val adults \u003d getAdults(powerRangers)\r\n      assert(adults \u003d\u003d\u003d List(Person(\"Yellow Ranger\", 18), Person(\"Pink Ranger\", 19)))\r\n    }\r\n\r\n  }\r\n\r\n  describe(\"reverseList\") {\r\n\r\n    it(\"should return the input list reversed\") {\r\n      val inputList \u003d List(1, 2, 3)\r\n      val result \u003d reverseList(inputList)\r\n      assert(result \u003d\u003d\u003d List(3, 2, 1))\r\n    }\r\n\r\n  }\r\n\r\n  describe(\"sublists\") {\r\n\r\n    it(\"should pack consecutive duplicates of list elements into sublists\") {\r\n      val inputList \u003d List(\"a\", \"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"a\", \"a\", \"d\", \"e\", \"e\", \"e\", \"e\")\r\n      val result \u003d sublists(inputList)\r\n      assert(result \u003d\u003d\u003d List(List(\"a\", \"a\", \"a\", \"a\"), List(\"b\"), List(\"c\", \"c\"), List(\"a\", \"a\"), List(\"d\"), List(\"e\", \"e\", \"e\", \"e\")))\r\n    }\r\n\r\n  }\r\n\r\n}\r\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didOpen(MetalsLanguageServer.scala:884)
	... 16 more

2020.12.07 20:17:25 INFO  time: compiled intro-to-scala in 96ms
Dec. 07, 2020 8:17:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/StringContext.scala",
      "languageId": "scala",
      "version": 1,
      "text": "/*\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n *\n * See the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.\n */\n\npackage scala\n\nimport java.lang.{ StringBuilder \u003d\u003e JLSBuilder }\nimport scala.annotation.tailrec\n\n/** This class provides the basic mechanism to do String Interpolation.\n * String Interpolation allows users\n * to embed variable references directly in *processed* string literals.\n * Here\u0027s an example:\n * {{{\n *   val name \u003d \"James\"\n *   println(s\"Hello, \\$name\")  // Hello, James\n * }}}\n *\n * Any processed string literal is rewritten as an instantiation and\n * method call against this class.   For example:\n * {{{\n *   s\"Hello, \\$name\"\n * }}}\n *\n * is rewritten to be:\n *\n * {{{\n *   StringContext(\"Hello, \", \"\").s(name)\n * }}}\n *\n * By default, this class provides the `raw`, `s` and `f` methods as\n * available interpolators.\n *\n * To provide your own string interpolator, create an implicit class\n * which adds a method to `StringContext`.  Here\u0027s an example:\n * {{{\n *    implicit class JsonHelper(private val sc: StringContext) extends AnyVal {\n *      def json(args: Any*): JSONObject \u003d ...\n *    }\n *    val x: JSONObject \u003d json\"{ a: \\$a }\"\n * }}}\n *\n *  Here the `JsonHelper` extension class implicitly adds the `json` method to\n *  `StringContext` which can be used for `json` string literals.\n *\n *  @since 2.10.0\n *  @param   parts  The parts that make up the interpolated string,\n *                  without the expressions that get inserted by interpolation.\n */\ncase class StringContext(parts: String*) {\n\n  import StringContext._\n\n  /** Checks that the length of the given argument `args` is one less than the number\n   *  of `parts` supplied to the enclosing `StringContext`.\n   *  @param `args` The arguments to be checked.\n   *  @throws IllegalArgumentException  if this is not the case.\n   */\n  def checkLengths(args: Seq[Any]): Unit \u003d\n    if (parts.length !\u003d args.length + 1)\n      throw new IllegalArgumentException(\"wrong number of arguments (\"+ args.length\n        +\") for interpolated string with \"+ parts.length +\" parts\")\n\n\n  /** The simple string interpolator.\n   *\n   *  It inserts its arguments between corresponding parts of the string context.\n   *  It also treats standard escape sequences as defined in the Scala specification.\n   *  Here\u0027s an example of usage:\n   *  {{{\n   *    val name \u003d \"James\"\n   *    println(s\"Hello, \\$name\")  // Hello, James\n   *  }}}\n   *  In this example, the expression \\$name is replaced with the `toString` of the\n   *  variable `name`.\n   *  The `s` interpolator can take the `toString` of any arbitrary expression within\n   *  a `\\${}` block, for example:\n   *  {{{\n   *    println(s\"1 + 1 \u003d \\${1 + 1}\")\n   *  }}}\n   *  will print the string `1 + 1 \u003d 2`.\n   *\n   *  @param `args` The arguments to be inserted into the resulting string.\n   *  @throws IllegalArgumentException\n   *          if the number of `parts` in the enclosing `StringContext` does not exceed\n   *          the number of arguments `arg` by exactly 1.\n   *  @throws StringContext.InvalidEscapeException\n   *          if a `parts` string contains a backslash (`\\`) character\n   *          that does not start a valid escape sequence.\n   *  @note   The Scala compiler may replace a call to this method with an equivalent, but more efficient,\n   *          use of a StringBuilder.\n   */\n  def s(args: Any*): String \u003d standardInterpolator(treatEscapes, args)\n\n  /** The raw string interpolator.\n   *\n   *  It inserts its arguments between corresponding parts of the string context.\n   *  As opposed to the simple string interpolator `s`, this one does not treat\n   *  standard escape sequences as defined in the Scala specification.\n   *\n   *  For example, the raw processed string `raw\"a\\nb\"` is equal to the scala string `\"a\\\\nb\"`.\n   *\n   *  \u0027\u0027Note:\u0027\u0027 Even when using the raw interpolator, Scala will preprocess unicode escapes.\n   *  For example:\n   *  {{{\n   *    scala\u003e raw\"\\u005cu0023\"\n   *    res0: String \u003d #\n   *  }}}\n   *\n   *  @param `args` The arguments to be inserted into the resulting string.\n   *  @throws IllegalArgumentException\n   *          if the number of `parts` in the enclosing `StringContext` does not exceed\n   *          the number of arguments `arg` by exactly 1.\n   *  @note   The Scala compiler may replace a call to this method with an equivalent, but more efficient,\n   *          use of a StringBuilder.\n   */\n  def raw(args: Any*): String \u003d standardInterpolator(identity, args)\n\n  def standardInterpolator(process: String \u003d\u003e String, args: Seq[Any]): String \u003d {\n    checkLengths(args)\n    val pi \u003d parts.iterator\n    val ai \u003d args.iterator\n    val bldr \u003d new JLSBuilder(process(pi.next()))\n    while (ai.hasNext) {\n      bldr append ai.next\n      bldr append process(pi.next())\n    }\n    bldr.toString\n  }\n\n  /** The formatted string interpolator.\n   *\n   *  It inserts its arguments between corresponding parts of the string context.\n   *  It also treats standard escape sequences as defined in the Scala specification.\n   *  Finally, if an interpolated expression is followed by a `parts` string\n   *  that starts with a formatting specifier, the expression is formatted according to that\n   *  specifier. All specifiers allowed in Java format strings are handled, and in the same\n   *  way they are treated in Java.\n   *\n   *  For example:\n   *  {{{\n   *    val height \u003d 1.9d\n   *    val name \u003d \"James\"\n   *    println(f\"\\$name%s is \\$height%2.2f meters tall\")  // James is 1.90 meters tall\n   *  }}}\n   *\n   *  @param `args` The arguments to be inserted into the resulting string.\n   *  @throws IllegalArgumentException\n   *          if the number of `parts` in the enclosing `StringContext` does not exceed\n   *          the number of arguments `arg` by exactly 1.\n   *  @throws StringContext.InvalidEscapeException\n   *          if a `parts` string contains a backslash (`\\`) character\n   *          that does not start a valid escape sequence.\n   *\n   *  Note: The `f` method works by assembling a format string from all the `parts` strings and using\n   *  `java.lang.String.format` to format all arguments with that format string. The format string is\n   *  obtained by concatenating all `parts` strings, and performing two transformations:\n   *\n   *   1. Let a _formatting position_ be a start of any `parts` string except the first one.\n   *      If a formatting position does not refer to a `%` character (which is assumed to\n   *      start a format specifier), then the string format specifier `%s` is inserted.\n   *\n   *   2. Any `%` characters not in formatting positions must begin one of the conversions\n   *      `%%` (the literal percent) or `%n` (the platform-specific line separator).\n   */\n  // The implementation is hardwired to `scala.tools.reflect.MacroImplementations.macro_StringInterpolation_f`\n  // Using the mechanism implemented in `scala.tools.reflect.FastTrack`\n  def f[A \u003e: Any](args: A*): String \u003d macro ???\n}\n\nobject StringContext {\n\n  /** An exception that is thrown if a string contains a backslash (`\\`) character\n   *  that does not start a valid escape sequence.\n   *  @param  str   The offending string\n   *  @param  index   The index of the offending backslash character in `str`.\n   */\n  class InvalidEscapeException(str: String, @deprecatedName(\u0027idx) val index: Int) extends IllegalArgumentException(\n    s\"\"\"invalid escape ${\n      require(index \u003e\u003d 0 \u0026\u0026 index \u003c str.length)\n      val ok \u003d \"\"\"[\\b, \\t, \\n, \\f, \\r, \\\\, \\\", \\\u0027]\"\"\"\n      if (index \u003d\u003d str.length - 1) \"at terminal\" else s\"\u0027\\\\${str(index + 1)}\u0027 not one of $ok at\"\n    } index $index in \"$str\". Use \\\\\\\\ for literal \\\\.\"\"\"\n  )\n\n  /** Expands standard Scala escape sequences in a string.\n   *  Escape sequences are:\n   *   control: `\\b`, `\\t`, `\\n`, `\\f`, `\\r`\n   *   escape:  `\\\\`, `\\\"`, `\\\u0027`\n   *   octal:   `\\d` `\\dd` `\\ddd` where `d` is an octal digit between `0` and `7`.\n   *\n   *  @param  str  A string that may contain escape sequences\n   *  @return The string with all escape sequences expanded.\n   */\n  def treatEscapes(str: String): String \u003d treatEscapes0(str, strict \u003d false)\n\n  /** Treats escapes, but disallows octal escape sequences. */\n  def processEscapes(str: String): String \u003d treatEscapes0(str, strict \u003d true)\n\n  private def treatEscapes0(str: String, strict: Boolean): String \u003d {\n    val len \u003d str.length\n    // replace escapes with given first escape\n    def replace(first: Int): String \u003d {\n      val b \u003d new JLSBuilder\n      // append replacement starting at index `i`, with `next` backslash\n      @tailrec def loop(i: Int, next: Int): String \u003d {\n        if (next \u003e\u003d 0) {\n          //require(str(next) \u003d\u003d \u0027\\\\\u0027)\n          if (next \u003e i) b.append(str, i, next)\n          var idx \u003d next + 1\n          if (idx \u003e\u003d len) throw new InvalidEscapeException(str, next)\n          val c \u003d str(idx) match {\n            case \u0027b\u0027  \u003d\u003e \u0027\\b\u0027\n            case \u0027t\u0027  \u003d\u003e \u0027\\t\u0027\n            case \u0027n\u0027  \u003d\u003e \u0027\\n\u0027\n            case \u0027f\u0027  \u003d\u003e \u0027\\f\u0027\n            case \u0027r\u0027  \u003d\u003e \u0027\\r\u0027\n            case \u0027\"\u0027  \u003d\u003e \u0027\"\u0027\n            case \u0027\\\u0027\u0027 \u003d\u003e \u0027\\\u0027\u0027\n            case \u0027\\\\\u0027 \u003d\u003e \u0027\\\\\u0027\n            case o if \u00270\u0027 \u003c\u003d o \u0026\u0026 o \u003c\u003d \u00277\u0027 \u003d\u003e\n              if (strict) throw new InvalidEscapeException(str, next)\n              val leadch \u003d str(idx)\n              var oct \u003d leadch - \u00270\u0027\n              idx +\u003d 1\n              if (idx \u003c len \u0026\u0026 \u00270\u0027 \u003c\u003d str(idx) \u0026\u0026 str(idx) \u003c\u003d \u00277\u0027) {\n                oct \u003d oct * 8 + str(idx) - \u00270\u0027\n                idx +\u003d 1\n                if (idx \u003c len \u0026\u0026 leadch \u003c\u003d \u00273\u0027 \u0026\u0026 \u00270\u0027 \u003c\u003d str(idx) \u0026\u0026 str(idx) \u003c\u003d \u00277\u0027) {\n                  oct \u003d oct * 8 + str(idx) - \u00270\u0027\n                  idx +\u003d 1\n                }\n              }\n              idx -\u003d 1   // retreat\n              oct.toChar\n            case _    \u003d\u003e throw new InvalidEscapeException(str, next)\n          }\n          idx +\u003d 1       // advance\n          b append c\n          loop(idx, str.indexOf(\u0027\\\\\u0027, idx))\n        } else {\n          if (i \u003c len) b.append(str, i, len)\n          b.toString\n        }\n      }\n      loop(0, first)\n    }\n    str indexOf \u0027\\\\\u0027 match {\n      case -1 \u003d\u003e str\n      case  i \u003d\u003e replace(i)\n    }\n  }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor23.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didOpen(MetalsLanguageServer.scala:884)
	... 15 more

2020.12.07 20:17:25 INFO  compiling intro-to-scala (1 scala source)
2020.12.07 20:17:28 INFO  time: compiled intro-to-scala in 2.11s
Dec. 07, 2020 8:31:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor21.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didFocus(MetalsLanguageServer.scala:934)
	... 15 more

something's wrong: no file:///C:/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala in List[introcourse.level03.Person]RangePosition(file:///C:/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala, 7938, 7938, 7950)
something's wrong: no file:///C:/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala in List[introcourse.level03.Person]RangePosition(file:///C:/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala, 7938, 7938, 7950)
Dec. 08, 2020 8:19:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level04/OptionExercises1.scala",
      "languageId": "scala",
      "version": 1,
      "text": "package introcourse.level04\r\n\r\n/**\r\n  * Here we introduce a new ADT - `Option` - for dealing with values that may not exist.\r\n  *\r\n  * We will also cover safe constructors, which in conjunction with ADTs, allow us to prevent invalid states from being represented.\r\n  */\r\nobject OptionExercises1 {\r\n\r\n  /**\r\n    * Option data type\r\n    *\r\n    * sealed trait Option[+A]\r\n    * case class Some[A](a: A) extends Option[A]\r\n    * case object None extends Option[Nothing]\r\n    */\r\n\r\n  /**\r\n    * scala\u003e safeMean(List(1, 2, 10))\r\n    * \u003e Some(4.333333333333333)\r\n    *\r\n    * scala\u003e safeMean(Nil)\r\n    * \u003e None\r\n    *\r\n    * Hint: Use `sum`, `length` and convert the numerator or denominator to a `Double` using `toDouble`\r\n    *\r\n    * If you do division on two `Int`s, you will get an `Int` back, which is often not what you want!\r\n    *\r\n    * scala\u003e 5 / 2\r\n    * \u003e 2\r\n    *\r\n    * scala\u003e 5.toDouble / 2\r\n    * \u003e 2.5\r\n    *\r\n    * scala\u003e 5 / 2.toDouble\r\n    * \u003e 2.5\r\n    **/\r\n  def safeMean(nums: List[Int]): Option[Double] \u003d ???\r\n\r\n  /**\r\n    * Safe constructors\r\n    *\r\n    * Allows us to convert input from the real world (e.g. files, HTTP request, etc.) into ADTs\r\n    */\r\n\r\n  /**\r\n    * scala\u003e mkTrafficLight(\"red\")\r\n    * \u003e Some(Red)\r\n    *\r\n    * scala\u003e mkTrafficLight(\"green\")\r\n    * \u003e Some(Green)\r\n    *\r\n    * scala\u003e mkTrafficLight(\"yellow\")\r\n    * \u003e Some(Yellow)\r\n    *\r\n    * scala\u003e mkTrafficLight(\"bob\")\r\n    * \u003e None\r\n    *\r\n    * Hint: Use pattern matching\r\n    **/\r\n  def mkTrafficLight(str: String): Option[TrafficLight] \u003d ???\r\n\r\n  /**\r\n    * scala\u003e mkTrafficLightThenShow(\"red\")\r\n    * \u003e \"Traffic light is red\"\r\n    *\r\n    * scala\u003e mkTrafficLightThenShow(\"green\")\r\n    * \u003e \"Traffic light is green\"\r\n    *\r\n    * scala\u003e mkTrafficLightThenShow(\"yellow\")\r\n    * \u003e \"Traffic light is yellow\"\r\n    *\r\n    * scala\u003e mkTrafficLightThenShow(\"bob\")\r\n    * \u003e \"Traffic light `bob` is invalid\"\r\n    *\r\n    * Hint: Use `mkTrafficLight` then pattern match.\r\n    *\r\n    * You can pattern match on `Option` using its two constructors `Some` and `None`:\r\n    *\r\n    * ```\r\n    * optSomething match {\r\n    *   case Some(a) \u003d\u003e // do something with `a`\r\n    *   case None \u003d\u003e // do something else\r\n    * }\r\n    * ```\r\n    */\r\n  def mkTrafficLightThenShow(str: String): String \u003d ???\r\n\r\n  /**\r\n    * scala\u003e mkPerson(\"Bob\", 20)\r\n    * \u003e Some(Person(\"Bob\", 20))\r\n    *\r\n    * If `name` is blank:\r\n    *\r\n    * scala\u003e mkPerson(\"\", 20)\r\n    * \u003e None\r\n    *\r\n    * If `age` \u003c 0:\r\n    *\r\n    * scala\u003e mkPerson(\"Bob\", -1)\r\n    * \u003e None\r\n    *\r\n    * Hint: Don\u0027t forget every if needs an else!\r\n    **/\r\n  def mkPerson(name: String, age: Int): Option[Person] \u003d ???\r\n\r\n  /**\r\n    * scala\u003e mkPersonThenChangeName(\"Bob\", 20, \"John\")\r\n    * \u003e Some(Person(\"John\", 20))\r\n    *\r\n    * scala\u003e mkPersonThenChangeName(\"Bob\", -1, \"John\")\r\n    * \u003e None\r\n    *\r\n    * scala\u003e mkPersonThenChangeName(\"Bob\", 20, \"\")\r\n    * \u003e None\r\n    *\r\n    * Hint: Use `mkPerson` and pattern matching\r\n    **/\r\n  def mkPersonThenChangeName(oldName: String, age: Int, newName: String): Option[Person] \u003d ???\r\n\r\n}\r\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor23.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didOpen(MetalsLanguageServer.scala:884)
	... 15 more

Dec. 08, 2020 8:19:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level04/NullExercises.scala",
      "languageId": "scala",
      "version": 1,
      "text": "package introcourse.level04\r\n\r\n/**\r\n  * These exercises are intended to show the problems that come with programming with `null`s.\r\n  *\r\n  * After these exercises, we will learn the alternative to using `null`s.\r\n  */\r\n@SuppressWarnings(Array(\"org.wartremover.warts.Null\"))\r\nobject NullExercises {\r\n\r\n  /**\r\n    * From here on, we will work with a `TrafficLight` type that is defined in `package.scala`\r\n    *\r\n    * For simplicity, this type does not have a `Flashing` light.\r\n    */\r\n\r\n  /**\r\n    * Let\u0027s start by converting `String`s from our nasty real world into our own `TrafficLight` ADT.\r\n    * If given an unrecognised value, return `null`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"red\")\r\n    * \u003e Red\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"green\")\r\n    * \u003e Green\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"yellow\")\r\n    * \u003e Yellow\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"bob\")\r\n    * \u003e null\r\n    **/\r\n  def mkTrafficLightOrNull(str: String): TrafficLight \u003d\r\n    str match {\r\n      case \"red\" \u003d\u003e ???\r\n      case \"yellow\" \u003d\u003e ???\r\n      case \"green\" \u003d\u003e ???\r\n      case _ \u003d\u003e ???\r\n    }\r\n\r\n  /**\r\n    * Write a function that calls `mkTrafficLightOrNull` and then turn each `TrafficLight` into a readable `String`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"red\")\r\n    * \u003e \"Traffic light is red\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"green\")\r\n    * \u003e \"Traffic light is green\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"yellow\")\r\n    * \u003e \"Traffic light is yellow\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"bob\")\r\n    * \u003e \"Traffic light is invalid\"\r\n    *\r\n    * Hint: Use `mkTrafficLightOrNull` and pattern matching\r\n    */\r\n  def mkTrafficLightOrNullThenShow(str: String): String \u003d ???\r\n\r\n  /**\r\n    * Write a function that converts values from the real world into a `Person`.\r\n    * If the `name` and `age` are invalid (as described below), return `null`.\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", 20)\r\n    * \u003e Person(\"Bob\", 20)\r\n    *\r\n    * If `name` is blank:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"\", 20)\r\n    * \u003e null\r\n    *\r\n    * If `age` \u003c 0:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", -1)\r\n    * \u003e null\r\n    **/\r\n  def mkPersonOrNull(name: String, age: Int): Person \u003d ???\r\n\r\n  /**\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"John\")\r\n    * \u003e Person(\"John\", 20)\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", -1, \"John\")\r\n    * \u003e null\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"\")\r\n    * \u003e null\r\n    *\r\n    * Hint: Use `mkPersonOrNull` and `changeName` (already implemented below)\r\n    **/\r\n  def mkPersonOrNullThenChangeName(oldName: String, age: Int, newName: String): Person \u003d ???\r\n\r\n  def changeName(newName: String, person: Person): Person \u003d person.copy(name \u003d newName)\r\n\r\n  /**\r\n    * Thought exercise: Does the following function return a `null`?\r\n    */\r\n  def mean(nums: List[Int]): Double \u003d ???\r\n\r\n}\r\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor23.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didOpen(MetalsLanguageServer.scala:884)
	... 15 more

Dec. 08, 2020 8:20:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level04/OptionExercises3.scala",
      "languageId": "scala",
      "version": 1,
      "text": "package introcourse.level04\r\n\r\nimport introcourse.level04.OptionExercises2.{HumanId, Job, JobId, findHumanById, findJobById, findJobIdByHumanId, findJobByHumanId}\r\n\r\n/**\r\n  * These exercises mirror the ones from `OptionExercises2.scala`,\r\n  * they are for the purpose of teaching for-comprehension, which is very useful for working with `Option`.\r\n  */\r\nobject OptionExercises3 {\r\n\r\n  /**\r\n    * Rewrite this function using for-comprehension syntax.\r\n    *\r\n    * scala\u003e findJobIdByHumanIdUsingFor(1)\r\n    * \u003e None\r\n    *\r\n    * scala\u003e findJobIdByHumanIdUsingFor(2)\r\n    * \u003e Some(1)\r\n    */\r\n  def findJobIdByHumanIdUsingFor(humanId: HumanId): Option[JobId] \u003d\r\n    findHumanById(humanId).flatMap(human \u003d\u003e human.optJobId)\r\n\r\n  /**\r\n    * Rewrite this function using for-comprehension syntax.\r\n    *\r\n    * scala\u003e findJobByHumanIdUsingFor(2)\r\n    * \u003e Some(Job(\"Teacher\", \"Expert in their field\"))\r\n    */\r\n  def findJobByHumanIdUsingFor(humanId: HumanId): Option[Job] \u003d\r\n    findJobIdByHumanId(humanId).flatMap(jobId \u003d\u003e findJobById(jobId))\r\n\r\n  /**\r\n    * Rewrite this function using for-comprehension syntax.\r\n    *\r\n    * scala\u003e findJobNameByHumanIdUsingFor(2)\r\n    * \u003e Some(\"Teacher\")\r\n    *\r\n    * scala\u003e findJobNameByHumanIdUsingFor(1)\r\n    * \u003e None\r\n    */\r\n  def findJobNameByHumanIdUsingFor(humanId: HumanId): Option[String] \u003d\r\n    findJobByHumanId(humanId).map(job \u003d\u003e job.name)\r\n}\r\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor23.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didOpen(MetalsLanguageServer.scala:884)
	... 15 more

Dec. 08, 2020 8:20:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level04/package.scala",
      "languageId": "scala",
      "version": 1,
      "text": "package introcourse\r\n\r\npackage object level04 {\r\n\r\n  case class Person(name: String, age: Int)\r\n\r\n  sealed trait TrafficLight\r\n\r\n  case object Red extends TrafficLight\r\n\r\n  case object Yellow extends TrafficLight\r\n\r\n  case object Green extends TrafficLight\r\n\r\n}\r\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor23.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didOpen(MetalsLanguageServer.scala:884)
	... 15 more

Dec. 08, 2020 8:20:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor21.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didFocus(MetalsLanguageServer.scala:934)
	... 15 more

Dec. 08, 2020 8:20:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level02/TypesExercises.scala"
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor21.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didFocus(MetalsLanguageServer.scala:934)
	... 15 more

Dec. 08, 2020 8:20:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level03/ListExercises.scala"
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor21.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didFocus(MetalsLanguageServer.scala:934)
	... 15 more

Dec. 08, 2020 8:20:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level04/NullExercises.scala",
      "languageId": "scala",
      "version": 1,
      "text": "package introcourse.level04\r\n\r\n/**\r\n  * These exercises are intended to show the problems that come with programming with `null`s.\r\n  *\r\n  * After these exercises, we will learn the alternative to using `null`s.\r\n  */\r\n@SuppressWarnings(Array(\"org.wartremover.warts.Null\"))\r\nobject NullExercises {\r\n\r\n  /**\r\n    * From here on, we will work with a `TrafficLight` type that is defined in `package.scala`\r\n    *\r\n    * For simplicity, this type does not have a `Flashing` light.\r\n    */\r\n\r\n  /**\r\n    * Let\u0027s start by converting `String`s from our nasty real world into our own `TrafficLight` ADT.\r\n    * If given an unrecognised value, return `null`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"red\")\r\n    * \u003e Red\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"green\")\r\n    * \u003e Green\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"yellow\")\r\n    * \u003e Yellow\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"bob\")\r\n    * \u003e null\r\n    **/\r\n  def mkTrafficLightOrNull(str: String): TrafficLight \u003d\r\n    str match {\r\n      case \"red\" \u003d\u003e ???\r\n      case \"yellow\" \u003d\u003e ???\r\n      case \"green\" \u003d\u003e ???\r\n      case _ \u003d\u003e ???\r\n    }\r\n\r\n  /**\r\n    * Write a function that calls `mkTrafficLightOrNull` and then turn each `TrafficLight` into a readable `String`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"red\")\r\n    * \u003e \"Traffic light is red\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"green\")\r\n    * \u003e \"Traffic light is green\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"yellow\")\r\n    * \u003e \"Traffic light is yellow\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"bob\")\r\n    * \u003e \"Traffic light is invalid\"\r\n    *\r\n    * Hint: Use `mkTrafficLightOrNull` and pattern matching\r\n    */\r\n  def mkTrafficLightOrNullThenShow(str: String): String \u003d ???\r\n\r\n  /**\r\n    * Write a function that converts values from the real world into a `Person`.\r\n    * If the `name` and `age` are invalid (as described below), return `null`.\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", 20)\r\n    * \u003e Person(\"Bob\", 20)\r\n    *\r\n    * If `name` is blank:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"\", 20)\r\n    * \u003e null\r\n    *\r\n    * If `age` \u003c 0:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", -1)\r\n    * \u003e null\r\n    **/\r\n  def mkPersonOrNull(name: String, age: Int): Person \u003d ???\r\n\r\n  /**\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"John\")\r\n    * \u003e Person(\"John\", 20)\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", -1, \"John\")\r\n    * \u003e null\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"\")\r\n    * \u003e null\r\n    *\r\n    * Hint: Use `mkPersonOrNull` and `changeName` (already implemented below)\r\n    **/\r\n  def mkPersonOrNullThenChangeName(oldName: String, age: Int, newName: String): Person \u003d ???\r\n\r\n  def changeName(newName: String, person: Person): Person \u003d person.copy(name \u003d newName)\r\n\r\n  /**\r\n    * Thought exercise: Does the following function return a `null`?\r\n    */\r\n  def mean(nums: List[Int]): Double \u003d ???\r\n\r\n}\r\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor23.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didOpen(MetalsLanguageServer.scala:884)
	... 15 more

Dec. 08, 2020 8:25:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 2,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level04/NullExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level04\r\n\r\n/**\r\n  * These exercises are intended to show the problems that come with programming with `null`s.\r\n  *\r\n  * After these exercises, we will learn the alternative to using `null`s.\r\n  */\r\n@SuppressWarnings(Array(\"org.wartremover.warts.Null\"))\r\nobject NullExercises {\r\n\r\n  /**\r\n    * From here on, we will work with a `TrafficLight` type that is defined in `package.scala`\r\n    *\r\n    * For simplicity, this type does not have a `Flashing` light.\r\n    */\r\n\r\n  /**\r\n    * Let\u0027s start by converting `String`s from our nasty real world into our own `TrafficLight` ADT.\r\n    * If given an unrecognised value, return `null`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"red\")\r\n    * \u003e Red\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"green\")\r\n    * \u003e Green\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"yellow\")\r\n    * \u003e Yellow\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"bob\")\r\n    * \u003e null\r\n    **/\r\n  def mkTrafficLightOrNull(str: String): TrafficLight \u003d\r\n    str match {\r\n      case \"red\" \u003d\u003e R\r\n      case \"yellow\" \u003d\u003e ???\r\n      case \"green\" \u003d\u003e ???\r\n      case _ \u003d\u003e ???\r\n    }\r\n\r\n  /**\r\n    * Write a function that calls `mkTrafficLightOrNull` and then turn each `TrafficLight` into a readable `String`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"red\")\r\n    * \u003e \"Traffic light is red\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"green\")\r\n    * \u003e \"Traffic light is green\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"yellow\")\r\n    * \u003e \"Traffic light is yellow\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"bob\")\r\n    * \u003e \"Traffic light is invalid\"\r\n    *\r\n    * Hint: Use `mkTrafficLightOrNull` and pattern matching\r\n    */\r\n  def mkTrafficLightOrNullThenShow(str: String): String \u003d ???\r\n\r\n  /**\r\n    * Write a function that converts values from the real world into a `Person`.\r\n    * If the `name` and `age` are invalid (as described below), return `null`.\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", 20)\r\n    * \u003e Person(\"Bob\", 20)\r\n    *\r\n    * If `name` is blank:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"\", 20)\r\n    * \u003e null\r\n    *\r\n    * If `age` \u003c 0:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", -1)\r\n    * \u003e null\r\n    **/\r\n  def mkPersonOrNull(name: String, age: Int): Person \u003d ???\r\n\r\n  /**\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"John\")\r\n    * \u003e Person(\"John\", 20)\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", -1, \"John\")\r\n    * \u003e null\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"\")\r\n    * \u003e null\r\n    *\r\n    * Hint: Use `mkPersonOrNull` and `changeName` (already implemented below)\r\n    **/\r\n  def mkPersonOrNullThenChangeName(oldName: String, age: Int, newName: String): Person \u003d ???\r\n\r\n  def changeName(newName: String, person: Person): Person \u003d person.copy(name \u003d newName)\r\n\r\n  /**\r\n    * Thought exercise: Does the following function return a `null`?\r\n    */\r\n  def mean(nums: List[Int]): Double \u003d ???\r\n\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 08, 2020 8:25:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 3,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level04/NullExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level04\r\n\r\n/**\r\n  * These exercises are intended to show the problems that come with programming with `null`s.\r\n  *\r\n  * After these exercises, we will learn the alternative to using `null`s.\r\n  */\r\n@SuppressWarnings(Array(\"org.wartremover.warts.Null\"))\r\nobject NullExercises {\r\n\r\n  /**\r\n    * From here on, we will work with a `TrafficLight` type that is defined in `package.scala`\r\n    *\r\n    * For simplicity, this type does not have a `Flashing` light.\r\n    */\r\n\r\n  /**\r\n    * Let\u0027s start by converting `String`s from our nasty real world into our own `TrafficLight` ADT.\r\n    * If given an unrecognised value, return `null`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"red\")\r\n    * \u003e Red\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"green\")\r\n    * \u003e Green\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"yellow\")\r\n    * \u003e Yellow\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"bob\")\r\n    * \u003e null\r\n    **/\r\n  def mkTrafficLightOrNull(str: String): TrafficLight \u003d\r\n    str match {\r\n      case \"red\" \u003d\u003e Re\r\n      case \"yellow\" \u003d\u003e ???\r\n      case \"green\" \u003d\u003e ???\r\n      case _ \u003d\u003e ???\r\n    }\r\n\r\n  /**\r\n    * Write a function that calls `mkTrafficLightOrNull` and then turn each `TrafficLight` into a readable `String`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"red\")\r\n    * \u003e \"Traffic light is red\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"green\")\r\n    * \u003e \"Traffic light is green\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"yellow\")\r\n    * \u003e \"Traffic light is yellow\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"bob\")\r\n    * \u003e \"Traffic light is invalid\"\r\n    *\r\n    * Hint: Use `mkTrafficLightOrNull` and pattern matching\r\n    */\r\n  def mkTrafficLightOrNullThenShow(str: String): String \u003d ???\r\n\r\n  /**\r\n    * Write a function that converts values from the real world into a `Person`.\r\n    * If the `name` and `age` are invalid (as described below), return `null`.\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", 20)\r\n    * \u003e Person(\"Bob\", 20)\r\n    *\r\n    * If `name` is blank:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"\", 20)\r\n    * \u003e null\r\n    *\r\n    * If `age` \u003c 0:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", -1)\r\n    * \u003e null\r\n    **/\r\n  def mkPersonOrNull(name: String, age: Int): Person \u003d ???\r\n\r\n  /**\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"John\")\r\n    * \u003e Person(\"John\", 20)\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", -1, \"John\")\r\n    * \u003e null\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"\")\r\n    * \u003e null\r\n    *\r\n    * Hint: Use `mkPersonOrNull` and `changeName` (already implemented below)\r\n    **/\r\n  def mkPersonOrNullThenChangeName(oldName: String, age: Int, newName: String): Person \u003d ???\r\n\r\n  def changeName(newName: String, person: Person): Person \u003d person.copy(name \u003d newName)\r\n\r\n  /**\r\n    * Thought exercise: Does the following function return a `null`?\r\n    */\r\n  def mean(nums: List[Int]): Double \u003d ???\r\n\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 08, 2020 8:25:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 4,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level04/NullExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level04\r\n\r\n/**\r\n  * These exercises are intended to show the problems that come with programming with `null`s.\r\n  *\r\n  * After these exercises, we will learn the alternative to using `null`s.\r\n  */\r\n@SuppressWarnings(Array(\"org.wartremover.warts.Null\"))\r\nobject NullExercises {\r\n\r\n  /**\r\n    * From here on, we will work with a `TrafficLight` type that is defined in `package.scala`\r\n    *\r\n    * For simplicity, this type does not have a `Flashing` light.\r\n    */\r\n\r\n  /**\r\n    * Let\u0027s start by converting `String`s from our nasty real world into our own `TrafficLight` ADT.\r\n    * If given an unrecognised value, return `null`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"red\")\r\n    * \u003e Red\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"green\")\r\n    * \u003e Green\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"yellow\")\r\n    * \u003e Yellow\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"bob\")\r\n    * \u003e null\r\n    **/\r\n  def mkTrafficLightOrNull(str: String): TrafficLight \u003d\r\n    str match {\r\n      case \"red\" \u003d\u003e Red\r\n      case \"yellow\" \u003d\u003e ???\r\n      case \"green\" \u003d\u003e ???\r\n      case _ \u003d\u003e ???\r\n    }\r\n\r\n  /**\r\n    * Write a function that calls `mkTrafficLightOrNull` and then turn each `TrafficLight` into a readable `String`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"red\")\r\n    * \u003e \"Traffic light is red\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"green\")\r\n    * \u003e \"Traffic light is green\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"yellow\")\r\n    * \u003e \"Traffic light is yellow\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"bob\")\r\n    * \u003e \"Traffic light is invalid\"\r\n    *\r\n    * Hint: Use `mkTrafficLightOrNull` and pattern matching\r\n    */\r\n  def mkTrafficLightOrNullThenShow(str: String): String \u003d ???\r\n\r\n  /**\r\n    * Write a function that converts values from the real world into a `Person`.\r\n    * If the `name` and `age` are invalid (as described below), return `null`.\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", 20)\r\n    * \u003e Person(\"Bob\", 20)\r\n    *\r\n    * If `name` is blank:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"\", 20)\r\n    * \u003e null\r\n    *\r\n    * If `age` \u003c 0:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", -1)\r\n    * \u003e null\r\n    **/\r\n  def mkPersonOrNull(name: String, age: Int): Person \u003d ???\r\n\r\n  /**\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"John\")\r\n    * \u003e Person(\"John\", 20)\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", -1, \"John\")\r\n    * \u003e null\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"\")\r\n    * \u003e null\r\n    *\r\n    * Hint: Use `mkPersonOrNull` and `changeName` (already implemented below)\r\n    **/\r\n  def mkPersonOrNullThenChangeName(oldName: String, age: Int, newName: String): Person \u003d ???\r\n\r\n  def changeName(newName: String, person: Person): Person \u003d person.copy(name \u003d newName)\r\n\r\n  /**\r\n    * Thought exercise: Does the following function return a `null`?\r\n    */\r\n  def mean(nums: List[Int]): Double \u003d ???\r\n\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 08, 2020 8:25:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 5,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level04/NullExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level04\r\n\r\n/**\r\n  * These exercises are intended to show the problems that come with programming with `null`s.\r\n  *\r\n  * After these exercises, we will learn the alternative to using `null`s.\r\n  */\r\n@SuppressWarnings(Array(\"org.wartremover.warts.Null\"))\r\nobject NullExercises {\r\n\r\n  /**\r\n    * From here on, we will work with a `TrafficLight` type that is defined in `package.scala`\r\n    *\r\n    * For simplicity, this type does not have a `Flashing` light.\r\n    */\r\n\r\n  /**\r\n    * Let\u0027s start by converting `String`s from our nasty real world into our own `TrafficLight` ADT.\r\n    * If given an unrecognised value, return `null`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"red\")\r\n    * \u003e Red\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"green\")\r\n    * \u003e Green\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"yellow\")\r\n    * \u003e Yellow\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"bob\")\r\n    * \u003e null\r\n    **/\r\n  def mkTrafficLightOrNull(str: String): TrafficLight \u003d\r\n    str match {\r\n      case \"red\" \u003d\u003e Red\r\n      case \"yellow\" \u003d\u003e ???\r\n      case \"green\" \u003d\u003e ???\r\n      case _ \u003d\u003e ???\r\n    }\r\n\r\n  /**\r\n    * Write a function that calls `mkTrafficLightOrNull` and then turn each `TrafficLight` into a readable `String`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"red\")\r\n    * \u003e \"Traffic light is red\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"green\")\r\n    * \u003e \"Traffic light is green\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"yellow\")\r\n    * \u003e \"Traffic light is yellow\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"bob\")\r\n    * \u003e \"Traffic light is invalid\"\r\n    *\r\n    * Hint: Use `mkTrafficLightOrNull` and pattern matching\r\n    */\r\n  def mkTrafficLightOrNullThenShow(str: String): String \u003d ???\r\n\r\n  /**\r\n    * Write a function that converts values from the real world into a `Person`.\r\n    * If the `name` and `age` are invalid (as described below), return `null`.\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", 20)\r\n    * \u003e Person(\"Bob\", 20)\r\n    *\r\n    * If `name` is blank:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"\", 20)\r\n    * \u003e null\r\n    *\r\n    * If `age` \u003c 0:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", -1)\r\n    * \u003e null\r\n    **/\r\n  def mkPersonOrNull(name: String, age: Int): Person \u003d ???\r\n\r\n  /**\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"John\")\r\n    * \u003e Person(\"John\", 20)\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", -1, \"John\")\r\n    * \u003e null\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"\")\r\n    * \u003e null\r\n    *\r\n    * Hint: Use `mkPersonOrNull` and `changeName` (already implemented below)\r\n    **/\r\n  def mkPersonOrNullThenChangeName(oldName: String, age: Int, newName: String): Person \u003d ???\r\n\r\n  def changeName(newName: String, person: Person): Person \u003d person.copy(name \u003d newName)\r\n\r\n  /**\r\n    * Thought exercise: Does the following function return a `null`?\r\n    */\r\n  def mean(nums: List[Int]): Double \u003d ???\r\n\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 08, 2020 8:25:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 6,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level04/NullExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level04\r\n\r\n/**\r\n  * These exercises are intended to show the problems that come with programming with `null`s.\r\n  *\r\n  * After these exercises, we will learn the alternative to using `null`s.\r\n  */\r\n@SuppressWarnings(Array(\"org.wartremover.warts.Null\"))\r\nobject NullExercises {\r\n\r\n  /**\r\n    * From here on, we will work with a `TrafficLight` type that is defined in `package.scala`\r\n    *\r\n    * For simplicity, this type does not have a `Flashing` light.\r\n    */\r\n\r\n  /**\r\n    * Let\u0027s start by converting `String`s from our nasty real world into our own `TrafficLight` ADT.\r\n    * If given an unrecognised value, return `null`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"red\")\r\n    * \u003e Red\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"green\")\r\n    * \u003e Green\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"yellow\")\r\n    * \u003e Yellow\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"bob\")\r\n    * \u003e null\r\n    **/\r\n  def mkTrafficLightOrNull(str: String): TrafficLight \u003d\r\n    str match {\r\n      case \"red\" \u003d\u003e Red\r\n      case \"yellow\" \u003d\u003e Y\r\n      case \"green\" \u003d\u003e ???\r\n      case _ \u003d\u003e ???\r\n    }\r\n\r\n  /**\r\n    * Write a function that calls `mkTrafficLightOrNull` and then turn each `TrafficLight` into a readable `String`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"red\")\r\n    * \u003e \"Traffic light is red\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"green\")\r\n    * \u003e \"Traffic light is green\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"yellow\")\r\n    * \u003e \"Traffic light is yellow\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"bob\")\r\n    * \u003e \"Traffic light is invalid\"\r\n    *\r\n    * Hint: Use `mkTrafficLightOrNull` and pattern matching\r\n    */\r\n  def mkTrafficLightOrNullThenShow(str: String): String \u003d ???\r\n\r\n  /**\r\n    * Write a function that converts values from the real world into a `Person`.\r\n    * If the `name` and `age` are invalid (as described below), return `null`.\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", 20)\r\n    * \u003e Person(\"Bob\", 20)\r\n    *\r\n    * If `name` is blank:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"\", 20)\r\n    * \u003e null\r\n    *\r\n    * If `age` \u003c 0:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", -1)\r\n    * \u003e null\r\n    **/\r\n  def mkPersonOrNull(name: String, age: Int): Person \u003d ???\r\n\r\n  /**\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"John\")\r\n    * \u003e Person(\"John\", 20)\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", -1, \"John\")\r\n    * \u003e null\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"\")\r\n    * \u003e null\r\n    *\r\n    * Hint: Use `mkPersonOrNull` and `changeName` (already implemented below)\r\n    **/\r\n  def mkPersonOrNullThenChangeName(oldName: String, age: Int, newName: String): Person \u003d ???\r\n\r\n  def changeName(newName: String, person: Person): Person \u003d person.copy(name \u003d newName)\r\n\r\n  /**\r\n    * Thought exercise: Does the following function return a `null`?\r\n    */\r\n  def mean(nums: List[Int]): Double \u003d ???\r\n\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 08, 2020 8:25:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 7,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level04/NullExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level04\r\n\r\n/**\r\n  * These exercises are intended to show the problems that come with programming with `null`s.\r\n  *\r\n  * After these exercises, we will learn the alternative to using `null`s.\r\n  */\r\n@SuppressWarnings(Array(\"org.wartremover.warts.Null\"))\r\nobject NullExercises {\r\n\r\n  /**\r\n    * From here on, we will work with a `TrafficLight` type that is defined in `package.scala`\r\n    *\r\n    * For simplicity, this type does not have a `Flashing` light.\r\n    */\r\n\r\n  /**\r\n    * Let\u0027s start by converting `String`s from our nasty real world into our own `TrafficLight` ADT.\r\n    * If given an unrecognised value, return `null`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"red\")\r\n    * \u003e Red\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"green\")\r\n    * \u003e Green\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"yellow\")\r\n    * \u003e Yellow\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"bob\")\r\n    * \u003e null\r\n    **/\r\n  def mkTrafficLightOrNull(str: String): TrafficLight \u003d\r\n    str match {\r\n      case \"red\" \u003d\u003e Red\r\n      case \"yellow\" \u003d\u003e Yellow\r\n      case \"green\" \u003d\u003e ???\r\n      case _ \u003d\u003e ???\r\n    }\r\n\r\n  /**\r\n    * Write a function that calls `mkTrafficLightOrNull` and then turn each `TrafficLight` into a readable `String`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"red\")\r\n    * \u003e \"Traffic light is red\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"green\")\r\n    * \u003e \"Traffic light is green\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"yellow\")\r\n    * \u003e \"Traffic light is yellow\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"bob\")\r\n    * \u003e \"Traffic light is invalid\"\r\n    *\r\n    * Hint: Use `mkTrafficLightOrNull` and pattern matching\r\n    */\r\n  def mkTrafficLightOrNullThenShow(str: String): String \u003d ???\r\n\r\n  /**\r\n    * Write a function that converts values from the real world into a `Person`.\r\n    * If the `name` and `age` are invalid (as described below), return `null`.\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", 20)\r\n    * \u003e Person(\"Bob\", 20)\r\n    *\r\n    * If `name` is blank:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"\", 20)\r\n    * \u003e null\r\n    *\r\n    * If `age` \u003c 0:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", -1)\r\n    * \u003e null\r\n    **/\r\n  def mkPersonOrNull(name: String, age: Int): Person \u003d ???\r\n\r\n  /**\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"John\")\r\n    * \u003e Person(\"John\", 20)\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", -1, \"John\")\r\n    * \u003e null\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"\")\r\n    * \u003e null\r\n    *\r\n    * Hint: Use `mkPersonOrNull` and `changeName` (already implemented below)\r\n    **/\r\n  def mkPersonOrNullThenChangeName(oldName: String, age: Int, newName: String): Person \u003d ???\r\n\r\n  def changeName(newName: String, person: Person): Person \u003d person.copy(name \u003d newName)\r\n\r\n  /**\r\n    * Thought exercise: Does the following function return a `null`?\r\n    */\r\n  def mean(nums: List[Int]): Double \u003d ???\r\n\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 08, 2020 8:25:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 10,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level04/NullExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level04\r\n\r\n/**\r\n  * These exercises are intended to show the problems that come with programming with `null`s.\r\n  *\r\n  * After these exercises, we will learn the alternative to using `null`s.\r\n  */\r\n@SuppressWarnings(Array(\"org.wartremover.warts.Null\"))\r\nobject NullExercises {\r\n\r\n  /**\r\n    * From here on, we will work with a `TrafficLight` type that is defined in `package.scala`\r\n    *\r\n    * For simplicity, this type does not have a `Flashing` light.\r\n    */\r\n\r\n  /**\r\n    * Let\u0027s start by converting `String`s from our nasty real world into our own `TrafficLight` ADT.\r\n    * If given an unrecognised value, return `null`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"red\")\r\n    * \u003e Red\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"green\")\r\n    * \u003e Green\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"yellow\")\r\n    * \u003e Yellow\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"bob\")\r\n    * \u003e null\r\n    **/\r\n  def mkTrafficLightOrNull(str: String): TrafficLight \u003d\r\n    str match {\r\n      case \"red\" \u003d\u003e Red\r\n      case \"yellow\" \u003d\u003e Yellow\r\n      case \"green\" \u003d\u003e \r\n      case _ \u003d\u003e ???\r\n    }\r\n\r\n  /**\r\n    * Write a function that calls `mkTrafficLightOrNull` and then turn each `TrafficLight` into a readable `String`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"red\")\r\n    * \u003e \"Traffic light is red\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"green\")\r\n    * \u003e \"Traffic light is green\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"yellow\")\r\n    * \u003e \"Traffic light is yellow\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"bob\")\r\n    * \u003e \"Traffic light is invalid\"\r\n    *\r\n    * Hint: Use `mkTrafficLightOrNull` and pattern matching\r\n    */\r\n  def mkTrafficLightOrNullThenShow(str: String): String \u003d ???\r\n\r\n  /**\r\n    * Write a function that converts values from the real world into a `Person`.\r\n    * If the `name` and `age` are invalid (as described below), return `null`.\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", 20)\r\n    * \u003e Person(\"Bob\", 20)\r\n    *\r\n    * If `name` is blank:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"\", 20)\r\n    * \u003e null\r\n    *\r\n    * If `age` \u003c 0:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", -1)\r\n    * \u003e null\r\n    **/\r\n  def mkPersonOrNull(name: String, age: Int): Person \u003d ???\r\n\r\n  /**\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"John\")\r\n    * \u003e Person(\"John\", 20)\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", -1, \"John\")\r\n    * \u003e null\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"\")\r\n    * \u003e null\r\n    *\r\n    * Hint: Use `mkPersonOrNull` and `changeName` (already implemented below)\r\n    **/\r\n  def mkPersonOrNullThenChangeName(oldName: String, age: Int, newName: String): Person \u003d ???\r\n\r\n  def changeName(newName: String, person: Person): Person \u003d person.copy(name \u003d newName)\r\n\r\n  /**\r\n    * Thought exercise: Does the following function return a `null`?\r\n    */\r\n  def mean(nums: List[Int]): Double \u003d ???\r\n\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 08, 2020 8:25:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 11,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level04/NullExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level04\r\n\r\n/**\r\n  * These exercises are intended to show the problems that come with programming with `null`s.\r\n  *\r\n  * After these exercises, we will learn the alternative to using `null`s.\r\n  */\r\n@SuppressWarnings(Array(\"org.wartremover.warts.Null\"))\r\nobject NullExercises {\r\n\r\n  /**\r\n    * From here on, we will work with a `TrafficLight` type that is defined in `package.scala`\r\n    *\r\n    * For simplicity, this type does not have a `Flashing` light.\r\n    */\r\n\r\n  /**\r\n    * Let\u0027s start by converting `String`s from our nasty real world into our own `TrafficLight` ADT.\r\n    * If given an unrecognised value, return `null`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"red\")\r\n    * \u003e Red\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"green\")\r\n    * \u003e Green\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"yellow\")\r\n    * \u003e Yellow\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"bob\")\r\n    * \u003e null\r\n    **/\r\n  def mkTrafficLightOrNull(str: String): TrafficLight \u003d\r\n    str match {\r\n      case \"red\" \u003d\u003e Red\r\n      case \"yellow\" \u003d\u003e Yellow\r\n      case \"green\" \u003d\u003e G\r\n      case _ \u003d\u003e ???\r\n    }\r\n\r\n  /**\r\n    * Write a function that calls `mkTrafficLightOrNull` and then turn each `TrafficLight` into a readable `String`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"red\")\r\n    * \u003e \"Traffic light is red\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"green\")\r\n    * \u003e \"Traffic light is green\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"yellow\")\r\n    * \u003e \"Traffic light is yellow\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"bob\")\r\n    * \u003e \"Traffic light is invalid\"\r\n    *\r\n    * Hint: Use `mkTrafficLightOrNull` and pattern matching\r\n    */\r\n  def mkTrafficLightOrNullThenShow(str: String): String \u003d ???\r\n\r\n  /**\r\n    * Write a function that converts values from the real world into a `Person`.\r\n    * If the `name` and `age` are invalid (as described below), return `null`.\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", 20)\r\n    * \u003e Person(\"Bob\", 20)\r\n    *\r\n    * If `name` is blank:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"\", 20)\r\n    * \u003e null\r\n    *\r\n    * If `age` \u003c 0:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", -1)\r\n    * \u003e null\r\n    **/\r\n  def mkPersonOrNull(name: String, age: Int): Person \u003d ???\r\n\r\n  /**\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"John\")\r\n    * \u003e Person(\"John\", 20)\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", -1, \"John\")\r\n    * \u003e null\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"\")\r\n    * \u003e null\r\n    *\r\n    * Hint: Use `mkPersonOrNull` and `changeName` (already implemented below)\r\n    **/\r\n  def mkPersonOrNullThenChangeName(oldName: String, age: Int, newName: String): Person \u003d ???\r\n\r\n  def changeName(newName: String, person: Person): Person \u003d person.copy(name \u003d newName)\r\n\r\n  /**\r\n    * Thought exercise: Does the following function return a `null`?\r\n    */\r\n  def mean(nums: List[Int]): Double \u003d ???\r\n\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 08, 2020 8:25:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 12,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level04/NullExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level04\r\n\r\n/**\r\n  * These exercises are intended to show the problems that come with programming with `null`s.\r\n  *\r\n  * After these exercises, we will learn the alternative to using `null`s.\r\n  */\r\n@SuppressWarnings(Array(\"org.wartremover.warts.Null\"))\r\nobject NullExercises {\r\n\r\n  /**\r\n    * From here on, we will work with a `TrafficLight` type that is defined in `package.scala`\r\n    *\r\n    * For simplicity, this type does not have a `Flashing` light.\r\n    */\r\n\r\n  /**\r\n    * Let\u0027s start by converting `String`s from our nasty real world into our own `TrafficLight` ADT.\r\n    * If given an unrecognised value, return `null`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"red\")\r\n    * \u003e Red\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"green\")\r\n    * \u003e Green\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"yellow\")\r\n    * \u003e Yellow\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"bob\")\r\n    * \u003e null\r\n    **/\r\n  def mkTrafficLightOrNull(str: String): TrafficLight \u003d\r\n    str match {\r\n      case \"red\" \u003d\u003e Red\r\n      case \"yellow\" \u003d\u003e Yellow\r\n      case \"green\" \u003d\u003e Gr\r\n      case _ \u003d\u003e ???\r\n    }\r\n\r\n  /**\r\n    * Write a function that calls `mkTrafficLightOrNull` and then turn each `TrafficLight` into a readable `String`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"red\")\r\n    * \u003e \"Traffic light is red\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"green\")\r\n    * \u003e \"Traffic light is green\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"yellow\")\r\n    * \u003e \"Traffic light is yellow\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"bob\")\r\n    * \u003e \"Traffic light is invalid\"\r\n    *\r\n    * Hint: Use `mkTrafficLightOrNull` and pattern matching\r\n    */\r\n  def mkTrafficLightOrNullThenShow(str: String): String \u003d ???\r\n\r\n  /**\r\n    * Write a function that converts values from the real world into a `Person`.\r\n    * If the `name` and `age` are invalid (as described below), return `null`.\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", 20)\r\n    * \u003e Person(\"Bob\", 20)\r\n    *\r\n    * If `name` is blank:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"\", 20)\r\n    * \u003e null\r\n    *\r\n    * If `age` \u003c 0:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", -1)\r\n    * \u003e null\r\n    **/\r\n  def mkPersonOrNull(name: String, age: Int): Person \u003d ???\r\n\r\n  /**\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"John\")\r\n    * \u003e Person(\"John\", 20)\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", -1, \"John\")\r\n    * \u003e null\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"\")\r\n    * \u003e null\r\n    *\r\n    * Hint: Use `mkPersonOrNull` and `changeName` (already implemented below)\r\n    **/\r\n  def mkPersonOrNullThenChangeName(oldName: String, age: Int, newName: String): Person \u003d ???\r\n\r\n  def changeName(newName: String, person: Person): Person \u003d person.copy(name \u003d newName)\r\n\r\n  /**\r\n    * Thought exercise: Does the following function return a `null`?\r\n    */\r\n  def mean(nums: List[Int]): Double \u003d ???\r\n\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 08, 2020 8:25:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 13,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level04/NullExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level04\r\n\r\n/**\r\n  * These exercises are intended to show the problems that come with programming with `null`s.\r\n  *\r\n  * After these exercises, we will learn the alternative to using `null`s.\r\n  */\r\n@SuppressWarnings(Array(\"org.wartremover.warts.Null\"))\r\nobject NullExercises {\r\n\r\n  /**\r\n    * From here on, we will work with a `TrafficLight` type that is defined in `package.scala`\r\n    *\r\n    * For simplicity, this type does not have a `Flashing` light.\r\n    */\r\n\r\n  /**\r\n    * Let\u0027s start by converting `String`s from our nasty real world into our own `TrafficLight` ADT.\r\n    * If given an unrecognised value, return `null`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"red\")\r\n    * \u003e Red\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"green\")\r\n    * \u003e Green\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"yellow\")\r\n    * \u003e Yellow\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"bob\")\r\n    * \u003e null\r\n    **/\r\n  def mkTrafficLightOrNull(str: String): TrafficLight \u003d\r\n    str match {\r\n      case \"red\" \u003d\u003e Red\r\n      case \"yellow\" \u003d\u003e Yellow\r\n      case \"green\" \u003d\u003e Gre\r\n      case _ \u003d\u003e ???\r\n    }\r\n\r\n  /**\r\n    * Write a function that calls `mkTrafficLightOrNull` and then turn each `TrafficLight` into a readable `String`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"red\")\r\n    * \u003e \"Traffic light is red\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"green\")\r\n    * \u003e \"Traffic light is green\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"yellow\")\r\n    * \u003e \"Traffic light is yellow\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"bob\")\r\n    * \u003e \"Traffic light is invalid\"\r\n    *\r\n    * Hint: Use `mkTrafficLightOrNull` and pattern matching\r\n    */\r\n  def mkTrafficLightOrNullThenShow(str: String): String \u003d ???\r\n\r\n  /**\r\n    * Write a function that converts values from the real world into a `Person`.\r\n    * If the `name` and `age` are invalid (as described below), return `null`.\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", 20)\r\n    * \u003e Person(\"Bob\", 20)\r\n    *\r\n    * If `name` is blank:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"\", 20)\r\n    * \u003e null\r\n    *\r\n    * If `age` \u003c 0:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", -1)\r\n    * \u003e null\r\n    **/\r\n  def mkPersonOrNull(name: String, age: Int): Person \u003d ???\r\n\r\n  /**\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"John\")\r\n    * \u003e Person(\"John\", 20)\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", -1, \"John\")\r\n    * \u003e null\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"\")\r\n    * \u003e null\r\n    *\r\n    * Hint: Use `mkPersonOrNull` and `changeName` (already implemented below)\r\n    **/\r\n  def mkPersonOrNullThenChangeName(oldName: String, age: Int, newName: String): Person \u003d ???\r\n\r\n  def changeName(newName: String, person: Person): Person \u003d person.copy(name \u003d newName)\r\n\r\n  /**\r\n    * Thought exercise: Does the following function return a `null`?\r\n    */\r\n  def mean(nums: List[Int]): Double \u003d ???\r\n\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 08, 2020 8:25:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 14,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level04/NullExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level04\r\n\r\n/**\r\n  * These exercises are intended to show the problems that come with programming with `null`s.\r\n  *\r\n  * After these exercises, we will learn the alternative to using `null`s.\r\n  */\r\n@SuppressWarnings(Array(\"org.wartremover.warts.Null\"))\r\nobject NullExercises {\r\n\r\n  /**\r\n    * From here on, we will work with a `TrafficLight` type that is defined in `package.scala`\r\n    *\r\n    * For simplicity, this type does not have a `Flashing` light.\r\n    */\r\n\r\n  /**\r\n    * Let\u0027s start by converting `String`s from our nasty real world into our own `TrafficLight` ADT.\r\n    * If given an unrecognised value, return `null`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"red\")\r\n    * \u003e Red\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"green\")\r\n    * \u003e Green\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"yellow\")\r\n    * \u003e Yellow\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"bob\")\r\n    * \u003e null\r\n    **/\r\n  def mkTrafficLightOrNull(str: String): TrafficLight \u003d\r\n    str match {\r\n      case \"red\" \u003d\u003e Red\r\n      case \"yellow\" \u003d\u003e Yellow\r\n      case \"green\" \u003d\u003e Green\r\n      case _ \u003d\u003e ???\r\n    }\r\n\r\n  /**\r\n    * Write a function that calls `mkTrafficLightOrNull` and then turn each `TrafficLight` into a readable `String`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"red\")\r\n    * \u003e \"Traffic light is red\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"green\")\r\n    * \u003e \"Traffic light is green\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"yellow\")\r\n    * \u003e \"Traffic light is yellow\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"bob\")\r\n    * \u003e \"Traffic light is invalid\"\r\n    *\r\n    * Hint: Use `mkTrafficLightOrNull` and pattern matching\r\n    */\r\n  def mkTrafficLightOrNullThenShow(str: String): String \u003d ???\r\n\r\n  /**\r\n    * Write a function that converts values from the real world into a `Person`.\r\n    * If the `name` and `age` are invalid (as described below), return `null`.\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", 20)\r\n    * \u003e Person(\"Bob\", 20)\r\n    *\r\n    * If `name` is blank:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"\", 20)\r\n    * \u003e null\r\n    *\r\n    * If `age` \u003c 0:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", -1)\r\n    * \u003e null\r\n    **/\r\n  def mkPersonOrNull(name: String, age: Int): Person \u003d ???\r\n\r\n  /**\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"John\")\r\n    * \u003e Person(\"John\", 20)\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", -1, \"John\")\r\n    * \u003e null\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"\")\r\n    * \u003e null\r\n    *\r\n    * Hint: Use `mkPersonOrNull` and `changeName` (already implemented below)\r\n    **/\r\n  def mkPersonOrNullThenChangeName(oldName: String, age: Int, newName: String): Person \u003d ???\r\n\r\n  def changeName(newName: String, person: Person): Person \u003d person.copy(name \u003d newName)\r\n\r\n  /**\r\n    * Thought exercise: Does the following function return a `null`?\r\n    */\r\n  def mean(nums: List[Int]): Double \u003d ???\r\n\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 08, 2020 8:25:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 17,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level04/NullExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level04\r\n\r\n/**\r\n  * These exercises are intended to show the problems that come with programming with `null`s.\r\n  *\r\n  * After these exercises, we will learn the alternative to using `null`s.\r\n  */\r\n@SuppressWarnings(Array(\"org.wartremover.warts.Null\"))\r\nobject NullExercises {\r\n\r\n  /**\r\n    * From here on, we will work with a `TrafficLight` type that is defined in `package.scala`\r\n    *\r\n    * For simplicity, this type does not have a `Flashing` light.\r\n    */\r\n\r\n  /**\r\n    * Let\u0027s start by converting `String`s from our nasty real world into our own `TrafficLight` ADT.\r\n    * If given an unrecognised value, return `null`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"red\")\r\n    * \u003e Red\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"green\")\r\n    * \u003e Green\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"yellow\")\r\n    * \u003e Yellow\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"bob\")\r\n    * \u003e null\r\n    **/\r\n  def mkTrafficLightOrNull(str: String): TrafficLight \u003d\r\n    str match {\r\n      case \"red\" \u003d\u003e Red\r\n      case \"yellow\" \u003d\u003e Yellow\r\n      case \"green\" \u003d\u003e Green\r\n      case _ \u003d\u003e \r\n    }\r\n\r\n  /**\r\n    * Write a function that calls `mkTrafficLightOrNull` and then turn each `TrafficLight` into a readable `String`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"red\")\r\n    * \u003e \"Traffic light is red\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"green\")\r\n    * \u003e \"Traffic light is green\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"yellow\")\r\n    * \u003e \"Traffic light is yellow\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"bob\")\r\n    * \u003e \"Traffic light is invalid\"\r\n    *\r\n    * Hint: Use `mkTrafficLightOrNull` and pattern matching\r\n    */\r\n  def mkTrafficLightOrNullThenShow(str: String): String \u003d ???\r\n\r\n  /**\r\n    * Write a function that converts values from the real world into a `Person`.\r\n    * If the `name` and `age` are invalid (as described below), return `null`.\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", 20)\r\n    * \u003e Person(\"Bob\", 20)\r\n    *\r\n    * If `name` is blank:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"\", 20)\r\n    * \u003e null\r\n    *\r\n    * If `age` \u003c 0:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", -1)\r\n    * \u003e null\r\n    **/\r\n  def mkPersonOrNull(name: String, age: Int): Person \u003d ???\r\n\r\n  /**\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"John\")\r\n    * \u003e Person(\"John\", 20)\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", -1, \"John\")\r\n    * \u003e null\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"\")\r\n    * \u003e null\r\n    *\r\n    * Hint: Use `mkPersonOrNull` and `changeName` (already implemented below)\r\n    **/\r\n  def mkPersonOrNullThenChangeName(oldName: String, age: Int, newName: String): Person \u003d ???\r\n\r\n  def changeName(newName: String, person: Person): Person \u003d person.copy(name \u003d newName)\r\n\r\n  /**\r\n    * Thought exercise: Does the following function return a `null`?\r\n    */\r\n  def mean(nums: List[Int]): Double \u003d ???\r\n\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 08, 2020 8:25:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 18,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level04/NullExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level04\r\n\r\n/**\r\n  * These exercises are intended to show the problems that come with programming with `null`s.\r\n  *\r\n  * After these exercises, we will learn the alternative to using `null`s.\r\n  */\r\n@SuppressWarnings(Array(\"org.wartremover.warts.Null\"))\r\nobject NullExercises {\r\n\r\n  /**\r\n    * From here on, we will work with a `TrafficLight` type that is defined in `package.scala`\r\n    *\r\n    * For simplicity, this type does not have a `Flashing` light.\r\n    */\r\n\r\n  /**\r\n    * Let\u0027s start by converting `String`s from our nasty real world into our own `TrafficLight` ADT.\r\n    * If given an unrecognised value, return `null`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"red\")\r\n    * \u003e Red\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"green\")\r\n    * \u003e Green\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"yellow\")\r\n    * \u003e Yellow\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"bob\")\r\n    * \u003e null\r\n    **/\r\n  def mkTrafficLightOrNull(str: String): TrafficLight \u003d\r\n    str match {\r\n      case \"red\" \u003d\u003e Red\r\n      case \"yellow\" \u003d\u003e Yellow\r\n      case \"green\" \u003d\u003e Green\r\n      case _ \u003d\u003e n\r\n    }\r\n\r\n  /**\r\n    * Write a function that calls `mkTrafficLightOrNull` and then turn each `TrafficLight` into a readable `String`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"red\")\r\n    * \u003e \"Traffic light is red\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"green\")\r\n    * \u003e \"Traffic light is green\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"yellow\")\r\n    * \u003e \"Traffic light is yellow\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"bob\")\r\n    * \u003e \"Traffic light is invalid\"\r\n    *\r\n    * Hint: Use `mkTrafficLightOrNull` and pattern matching\r\n    */\r\n  def mkTrafficLightOrNullThenShow(str: String): String \u003d ???\r\n\r\n  /**\r\n    * Write a function that converts values from the real world into a `Person`.\r\n    * If the `name` and `age` are invalid (as described below), return `null`.\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", 20)\r\n    * \u003e Person(\"Bob\", 20)\r\n    *\r\n    * If `name` is blank:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"\", 20)\r\n    * \u003e null\r\n    *\r\n    * If `age` \u003c 0:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", -1)\r\n    * \u003e null\r\n    **/\r\n  def mkPersonOrNull(name: String, age: Int): Person \u003d ???\r\n\r\n  /**\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"John\")\r\n    * \u003e Person(\"John\", 20)\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", -1, \"John\")\r\n    * \u003e null\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"\")\r\n    * \u003e null\r\n    *\r\n    * Hint: Use `mkPersonOrNull` and `changeName` (already implemented below)\r\n    **/\r\n  def mkPersonOrNullThenChangeName(oldName: String, age: Int, newName: String): Person \u003d ???\r\n\r\n  def changeName(newName: String, person: Person): Person \u003d person.copy(name \u003d newName)\r\n\r\n  /**\r\n    * Thought exercise: Does the following function return a `null`?\r\n    */\r\n  def mean(nums: List[Int]): Double \u003d ???\r\n\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 08, 2020 8:25:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 19,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level04/NullExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level04\r\n\r\n/**\r\n  * These exercises are intended to show the problems that come with programming with `null`s.\r\n  *\r\n  * After these exercises, we will learn the alternative to using `null`s.\r\n  */\r\n@SuppressWarnings(Array(\"org.wartremover.warts.Null\"))\r\nobject NullExercises {\r\n\r\n  /**\r\n    * From here on, we will work with a `TrafficLight` type that is defined in `package.scala`\r\n    *\r\n    * For simplicity, this type does not have a `Flashing` light.\r\n    */\r\n\r\n  /**\r\n    * Let\u0027s start by converting `String`s from our nasty real world into our own `TrafficLight` ADT.\r\n    * If given an unrecognised value, return `null`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"red\")\r\n    * \u003e Red\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"green\")\r\n    * \u003e Green\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"yellow\")\r\n    * \u003e Yellow\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"bob\")\r\n    * \u003e null\r\n    **/\r\n  def mkTrafficLightOrNull(str: String): TrafficLight \u003d\r\n    str match {\r\n      case \"red\" \u003d\u003e Red\r\n      case \"yellow\" \u003d\u003e Yellow\r\n      case \"green\" \u003d\u003e Green\r\n      case _ \u003d\u003e nu\r\n    }\r\n\r\n  /**\r\n    * Write a function that calls `mkTrafficLightOrNull` and then turn each `TrafficLight` into a readable `String`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"red\")\r\n    * \u003e \"Traffic light is red\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"green\")\r\n    * \u003e \"Traffic light is green\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"yellow\")\r\n    * \u003e \"Traffic light is yellow\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"bob\")\r\n    * \u003e \"Traffic light is invalid\"\r\n    *\r\n    * Hint: Use `mkTrafficLightOrNull` and pattern matching\r\n    */\r\n  def mkTrafficLightOrNullThenShow(str: String): String \u003d ???\r\n\r\n  /**\r\n    * Write a function that converts values from the real world into a `Person`.\r\n    * If the `name` and `age` are invalid (as described below), return `null`.\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", 20)\r\n    * \u003e Person(\"Bob\", 20)\r\n    *\r\n    * If `name` is blank:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"\", 20)\r\n    * \u003e null\r\n    *\r\n    * If `age` \u003c 0:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", -1)\r\n    * \u003e null\r\n    **/\r\n  def mkPersonOrNull(name: String, age: Int): Person \u003d ???\r\n\r\n  /**\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"John\")\r\n    * \u003e Person(\"John\", 20)\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", -1, \"John\")\r\n    * \u003e null\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"\")\r\n    * \u003e null\r\n    *\r\n    * Hint: Use `mkPersonOrNull` and `changeName` (already implemented below)\r\n    **/\r\n  def mkPersonOrNullThenChangeName(oldName: String, age: Int, newName: String): Person \u003d ???\r\n\r\n  def changeName(newName: String, person: Person): Person \u003d person.copy(name \u003d newName)\r\n\r\n  /**\r\n    * Thought exercise: Does the following function return a `null`?\r\n    */\r\n  def mean(nums: List[Int]): Double \u003d ???\r\n\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 08, 2020 8:25:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 20,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level04/NullExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level04\r\n\r\n/**\r\n  * These exercises are intended to show the problems that come with programming with `null`s.\r\n  *\r\n  * After these exercises, we will learn the alternative to using `null`s.\r\n  */\r\n@SuppressWarnings(Array(\"org.wartremover.warts.Null\"))\r\nobject NullExercises {\r\n\r\n  /**\r\n    * From here on, we will work with a `TrafficLight` type that is defined in `package.scala`\r\n    *\r\n    * For simplicity, this type does not have a `Flashing` light.\r\n    */\r\n\r\n  /**\r\n    * Let\u0027s start by converting `String`s from our nasty real world into our own `TrafficLight` ADT.\r\n    * If given an unrecognised value, return `null`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"red\")\r\n    * \u003e Red\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"green\")\r\n    * \u003e Green\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"yellow\")\r\n    * \u003e Yellow\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"bob\")\r\n    * \u003e null\r\n    **/\r\n  def mkTrafficLightOrNull(str: String): TrafficLight \u003d\r\n    str match {\r\n      case \"red\" \u003d\u003e Red\r\n      case \"yellow\" \u003d\u003e Yellow\r\n      case \"green\" \u003d\u003e Green\r\n      case _ \u003d\u003e nul\r\n    }\r\n\r\n  /**\r\n    * Write a function that calls `mkTrafficLightOrNull` and then turn each `TrafficLight` into a readable `String`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"red\")\r\n    * \u003e \"Traffic light is red\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"green\")\r\n    * \u003e \"Traffic light is green\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"yellow\")\r\n    * \u003e \"Traffic light is yellow\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"bob\")\r\n    * \u003e \"Traffic light is invalid\"\r\n    *\r\n    * Hint: Use `mkTrafficLightOrNull` and pattern matching\r\n    */\r\n  def mkTrafficLightOrNullThenShow(str: String): String \u003d ???\r\n\r\n  /**\r\n    * Write a function that converts values from the real world into a `Person`.\r\n    * If the `name` and `age` are invalid (as described below), return `null`.\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", 20)\r\n    * \u003e Person(\"Bob\", 20)\r\n    *\r\n    * If `name` is blank:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"\", 20)\r\n    * \u003e null\r\n    *\r\n    * If `age` \u003c 0:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", -1)\r\n    * \u003e null\r\n    **/\r\n  def mkPersonOrNull(name: String, age: Int): Person \u003d ???\r\n\r\n  /**\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"John\")\r\n    * \u003e Person(\"John\", 20)\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", -1, \"John\")\r\n    * \u003e null\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"\")\r\n    * \u003e null\r\n    *\r\n    * Hint: Use `mkPersonOrNull` and `changeName` (already implemented below)\r\n    **/\r\n  def mkPersonOrNullThenChangeName(oldName: String, age: Int, newName: String): Person \u003d ???\r\n\r\n  def changeName(newName: String, person: Person): Person \u003d person.copy(name \u003d newName)\r\n\r\n  /**\r\n    * Thought exercise: Does the following function return a `null`?\r\n    */\r\n  def mean(nums: List[Int]): Double \u003d ???\r\n\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

Dec. 08, 2020 8:25:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 21,
      "uri": "file:///c%3A/Users/User/Documents/projects/intro-to-scala/src/main/scala/introcourse/level04/NullExercises.scala"
    },
    "contentChanges": [
      {
        "text": "package introcourse.level04\r\n\r\n/**\r\n  * These exercises are intended to show the problems that come with programming with `null`s.\r\n  *\r\n  * After these exercises, we will learn the alternative to using `null`s.\r\n  */\r\n@SuppressWarnings(Array(\"org.wartremover.warts.Null\"))\r\nobject NullExercises {\r\n\r\n  /**\r\n    * From here on, we will work with a `TrafficLight` type that is defined in `package.scala`\r\n    *\r\n    * For simplicity, this type does not have a `Flashing` light.\r\n    */\r\n\r\n  /**\r\n    * Let\u0027s start by converting `String`s from our nasty real world into our own `TrafficLight` ADT.\r\n    * If given an unrecognised value, return `null`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"red\")\r\n    * \u003e Red\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"green\")\r\n    * \u003e Green\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"yellow\")\r\n    * \u003e Yellow\r\n    *\r\n    * scala\u003e mkTrafficLightOrNull(\"bob\")\r\n    * \u003e null\r\n    **/\r\n  def mkTrafficLightOrNull(str: String): TrafficLight \u003d\r\n    str match {\r\n      case \"red\" \u003d\u003e Red\r\n      case \"yellow\" \u003d\u003e Yellow\r\n      case \"green\" \u003d\u003e Green\r\n      case _ \u003d\u003e null\r\n    }\r\n\r\n  /**\r\n    * Write a function that calls `mkTrafficLightOrNull` and then turn each `TrafficLight` into a readable `String`.\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"red\")\r\n    * \u003e \"Traffic light is red\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"green\")\r\n    * \u003e \"Traffic light is green\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"yellow\")\r\n    * \u003e \"Traffic light is yellow\"\r\n    *\r\n    * scala\u003e mkTrafficLightOrNullThenShow(\"bob\")\r\n    * \u003e \"Traffic light is invalid\"\r\n    *\r\n    * Hint: Use `mkTrafficLightOrNull` and pattern matching\r\n    */\r\n  def mkTrafficLightOrNullThenShow(str: String): String \u003d ???\r\n\r\n  /**\r\n    * Write a function that converts values from the real world into a `Person`.\r\n    * If the `name` and `age` are invalid (as described below), return `null`.\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", 20)\r\n    * \u003e Person(\"Bob\", 20)\r\n    *\r\n    * If `name` is blank:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"\", 20)\r\n    * \u003e null\r\n    *\r\n    * If `age` \u003c 0:\r\n    *\r\n    * scala\u003e mkPersonOrNull(\"Bob\", -1)\r\n    * \u003e null\r\n    **/\r\n  def mkPersonOrNull(name: String, age: Int): Person \u003d ???\r\n\r\n  /**\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"John\")\r\n    * \u003e Person(\"John\", 20)\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", -1, \"John\")\r\n    * \u003e null\r\n    *\r\n    * scala\u003e mkPersonOrNullThenChangeName(\"Bob\", 20, \"\")\r\n    * \u003e null\r\n    *\r\n    * Hint: Use `mkPersonOrNull` and `changeName` (already implemented below)\r\n    **/\r\n  def mkPersonOrNullThenChangeName(oldName: String, age: Int, newName: String): Person \u003d ???\r\n\r\n  def changeName(newName: String, person: Person): Person \u003d person.copy(name \u003d newName)\r\n\r\n  /**\r\n    * Thought exercise: Does the following function return a `null`?\r\n    */\r\n  def mean(nums: List[Int]): Double \u003d ???\r\n\r\n}\r\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.InvalidPathException: Illegal char <:> at index 4: file:///C:/Users/User/Documents/projects/intro-to-scala/.metals/readonly/scala/collection/immutable/List.scala
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:229)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.io.AbsolutePath.resolve(AbsolutePath.scala:43)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:238)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:66)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:986)
	... 15 more

2020.12.08 20:25:23 INFO  compiling intro-to-scala (1 scala source)
2020.12.08 20:25:24 INFO  time: compiled intro-to-scala in 1.13s
2020.12.08 20:27:26 INFO  compiling intro-to-scala (1 scala source)
2020.12.08 20:27:26 INFO  time: compiled intro-to-scala in 0.68s
2020.12.08 20:51:37 INFO  shutting down Metals
2020.12.08 20:51:37 INFO  Shut down connection with build server.
No more data in the client stdin, exiting...
No more data in the server stdin, exiting...
2020.12.08 20:51:37 INFO  Shut down connection with build server.
No more data in the client stdin, exiting...
No more data in the server stdin, exiting...
2020.12.08 20:51:37 INFO  Shut down connection with build server.
No more data in the client stdin, exiting...
No more data in the server stdin, exiting...
